{"ast":null,"code":"import _asyncToGenerator from \"/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _NetworkManager_instances, _NetworkManager_client, _NetworkManager_ignoreHTTPSErrors, _NetworkManager_frameManager, _NetworkManager_networkEventManager, _NetworkManager_extraHTTPHeaders, _NetworkManager_credentials, _NetworkManager_attemptedAuthentications, _NetworkManager_userRequestInterceptionEnabled, _NetworkManager_protocolRequestInterceptionEnabled, _NetworkManager_userCacheDisabled, _NetworkManager_emulatedNetworkConditions, _NetworkManager_deferredInitPromise, _NetworkManager_updateNetworkConditions, _NetworkManager_updateProtocolRequestInterception, _NetworkManager_cacheDisabled, _NetworkManager_updateProtocolCacheDisabled, _NetworkManager_onRequestWillBeSent, _NetworkManager_onAuthRequired, _NetworkManager_onRequestPaused, _NetworkManager_patchRequestEventHeaders, _NetworkManager_onRequest, _NetworkManager_onRequestServedFromCache, _NetworkManager_handleRequestRedirect, _NetworkManager_emitResponseEvent, _NetworkManager_onResponseReceived, _NetworkManager_onResponseReceivedExtraInfo, _NetworkManager_forgetRequest, _NetworkManager_onLoadingFinished, _NetworkManager_emitLoadingFinished, _NetworkManager_onLoadingFailed, _NetworkManager_emitLoadingFailed;\nimport { assert } from '../util/assert.js';\nimport { createDebuggableDeferredPromise } from '../util/DebuggableDeferredPromise.js';\nimport { EventEmitter } from './EventEmitter.js';\nimport { HTTPRequest } from './HTTPRequest.js';\nimport { HTTPResponse } from './HTTPResponse.js';\nimport { NetworkEventManager } from './NetworkEventManager.js';\nimport { debugError, isString } from './util.js';\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexport const NetworkManagerEmittedEvents = {\n  Request: Symbol('NetworkManager.Request'),\n  RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n  Response: Symbol('NetworkManager.Response'),\n  RequestFailed: Symbol('NetworkManager.RequestFailed'),\n  RequestFinished: Symbol('NetworkManager.RequestFinished')\n};\n/**\n * @internal\n */\nexport class NetworkManager extends EventEmitter {\n  constructor(client, ignoreHTTPSErrors, frameManager) {\n    super();\n    _NetworkManager_instances.add(this);\n    _NetworkManager_client.set(this, void 0);\n    _NetworkManager_ignoreHTTPSErrors.set(this, void 0);\n    _NetworkManager_frameManager.set(this, void 0);\n    _NetworkManager_networkEventManager.set(this, new NetworkEventManager());\n    _NetworkManager_extraHTTPHeaders.set(this, {});\n    _NetworkManager_credentials.set(this, void 0);\n    _NetworkManager_attemptedAuthentications.set(this, new Set());\n    _NetworkManager_userRequestInterceptionEnabled.set(this, false);\n    _NetworkManager_protocolRequestInterceptionEnabled.set(this, false);\n    _NetworkManager_userCacheDisabled.set(this, false);\n    _NetworkManager_emulatedNetworkConditions.set(this, {\n      offline: false,\n      upload: -1,\n      download: -1,\n      latency: 0\n    });\n    _NetworkManager_deferredInitPromise.set(this, void 0);\n    __classPrivateFieldSet(this, _NetworkManager_client, client, \"f\");\n    __classPrivateFieldSet(this, _NetworkManager_ignoreHTTPSErrors, ignoreHTTPSErrors, \"f\");\n    __classPrivateFieldSet(this, _NetworkManager_frameManager, frameManager, \"f\");\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Fetch.requestPaused', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequestPaused).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Fetch.authRequired', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onAuthRequired).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.requestWillBeSent', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequestWillBeSent).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.requestServedFromCache', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequestServedFromCache).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.responseReceived', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onResponseReceived).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.loadingFinished', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onLoadingFinished).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.loadingFailed', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onLoadingFailed).bind(this));\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.responseReceivedExtraInfo', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onResponseReceivedExtraInfo).bind(this));\n  }\n  /**\n   * Initialize calls should avoid async dependencies between CDP calls as those\n   * might not resolve until after the target is resumed causing a deadlock.\n   */\n  initialize() {\n    if (__classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\")) {\n      return __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\");\n    }\n    __classPrivateFieldSet(this, _NetworkManager_deferredInitPromise, createDebuggableDeferredPromise('NetworkManager initialization timed out'), \"f\");\n    const init = Promise.all([__classPrivateFieldGet(this, _NetworkManager_ignoreHTTPSErrors, \"f\") ? __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Security.setIgnoreCertificateErrors', {\n      ignore: true\n    }) : null, __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.enable')]);\n    const deferredInitPromise = __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\");\n    init.then(() => {\n      deferredInitPromise.resolve();\n    }).catch(err => {\n      deferredInitPromise.reject(err);\n    });\n    return __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\");\n  }\n  authenticate(credentials) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      __classPrivateFieldSet(_this, _NetworkManager_credentials, credentials, \"f\");\n      yield __classPrivateFieldGet(_this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolRequestInterception).call(_this);\n    })();\n  }\n  setExtraHTTPHeaders(extraHTTPHeaders) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      __classPrivateFieldSet(_this2, _NetworkManager_extraHTTPHeaders, {}, \"f\");\n      for (const key of Object.keys(extraHTTPHeaders)) {\n        const value = extraHTTPHeaders[key];\n        assert(isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n        __classPrivateFieldGet(_this2, _NetworkManager_extraHTTPHeaders, \"f\")[key.toLowerCase()] = value;\n      }\n      yield __classPrivateFieldGet(_this2, _NetworkManager_client, \"f\").send('Network.setExtraHTTPHeaders', {\n        headers: __classPrivateFieldGet(_this2, _NetworkManager_extraHTTPHeaders, \"f\")\n      });\n    })();\n  }\n  extraHTTPHeaders() {\n    return Object.assign({}, __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, \"f\"));\n  }\n  numRequestsInProgress() {\n    return __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").numRequestsInProgress();\n  }\n  setOfflineMode(value) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      __classPrivateFieldGet(_this3, _NetworkManager_emulatedNetworkConditions, \"f\").offline = value;\n      yield __classPrivateFieldGet(_this3, _NetworkManager_instances, \"m\", _NetworkManager_updateNetworkConditions).call(_this3);\n    })();\n  }\n  emulateNetworkConditions(networkConditions) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      __classPrivateFieldGet(_this4, _NetworkManager_emulatedNetworkConditions, \"f\").upload = networkConditions ? networkConditions.upload : -1;\n      __classPrivateFieldGet(_this4, _NetworkManager_emulatedNetworkConditions, \"f\").download = networkConditions ? networkConditions.download : -1;\n      __classPrivateFieldGet(_this4, _NetworkManager_emulatedNetworkConditions, \"f\").latency = networkConditions ? networkConditions.latency : 0;\n      yield __classPrivateFieldGet(_this4, _NetworkManager_instances, \"m\", _NetworkManager_updateNetworkConditions).call(_this4);\n    })();\n  }\n  setUserAgent(userAgent, userAgentMetadata) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield __classPrivateFieldGet(_this5, _NetworkManager_client, \"f\").send('Network.setUserAgentOverride', {\n        userAgent: userAgent,\n        userAgentMetadata: userAgentMetadata\n      });\n    })();\n  }\n  setCacheEnabled(enabled) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      __classPrivateFieldSet(_this6, _NetworkManager_userCacheDisabled, !enabled, \"f\");\n      yield __classPrivateFieldGet(_this6, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolCacheDisabled).call(_this6);\n    })();\n  }\n  setRequestInterception(value) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      __classPrivateFieldSet(_this7, _NetworkManager_userRequestInterceptionEnabled, value, \"f\");\n      yield __classPrivateFieldGet(_this7, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolRequestInterception).call(_this7);\n    })();\n  }\n}\n_NetworkManager_client = new WeakMap(), _NetworkManager_ignoreHTTPSErrors = new WeakMap(), _NetworkManager_frameManager = new WeakMap(), _NetworkManager_networkEventManager = new WeakMap(), _NetworkManager_extraHTTPHeaders = new WeakMap(), _NetworkManager_credentials = new WeakMap(), _NetworkManager_attemptedAuthentications = new WeakMap(), _NetworkManager_userRequestInterceptionEnabled = new WeakMap(), _NetworkManager_protocolRequestInterceptionEnabled = new WeakMap(), _NetworkManager_userCacheDisabled = new WeakMap(), _NetworkManager_emulatedNetworkConditions = new WeakMap(), _NetworkManager_deferredInitPromise = new WeakMap(), _NetworkManager_instances = new WeakSet(), _NetworkManager_updateNetworkConditions = /*#__PURE__*/function () {\n  var _NetworkManager_updateNetworkConditions2 = _asyncToGenerator(function* () {\n    yield __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.emulateNetworkConditions', {\n      offline: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").offline,\n      latency: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").latency,\n      uploadThroughput: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").upload,\n      downloadThroughput: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").download\n    });\n  });\n  function _NetworkManager_updateNetworkConditions() {\n    return _NetworkManager_updateNetworkConditions2.apply(this, arguments);\n  }\n  return _NetworkManager_updateNetworkConditions;\n}(), _NetworkManager_updateProtocolRequestInterception = /*#__PURE__*/function () {\n  var _NetworkManager_updateProtocolRequestInterception2 = _asyncToGenerator(function* () {\n    const enabled = __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\") || !!__classPrivateFieldGet(this, _NetworkManager_credentials, \"f\");\n    if (enabled === __classPrivateFieldGet(this, _NetworkManager_protocolRequestInterceptionEnabled, \"f\")) {\n      return;\n    }\n    __classPrivateFieldSet(this, _NetworkManager_protocolRequestInterceptionEnabled, enabled, \"f\");\n    if (enabled) {\n      yield Promise.all([__classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolCacheDisabled).call(this), __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Fetch.enable', {\n        handleAuthRequests: true,\n        patterns: [{\n          urlPattern: '*'\n        }]\n      })]);\n    } else {\n      yield Promise.all([__classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolCacheDisabled).call(this), __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Fetch.disable')]);\n    }\n  });\n  function _NetworkManager_updateProtocolRequestInterception() {\n    return _NetworkManager_updateProtocolRequestInterception2.apply(this, arguments);\n  }\n  return _NetworkManager_updateProtocolRequestInterception;\n}(), _NetworkManager_cacheDisabled = function _NetworkManager_cacheDisabled() {\n  return __classPrivateFieldGet(this, _NetworkManager_userCacheDisabled, \"f\");\n}, _NetworkManager_updateProtocolCacheDisabled = /*#__PURE__*/function () {\n  var _NetworkManager_updateProtocolCacheDisabled2 = _asyncToGenerator(function* () {\n    yield __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.setCacheDisabled', {\n      cacheDisabled: __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_cacheDisabled).call(this)\n    });\n  });\n  function _NetworkManager_updateProtocolCacheDisabled() {\n    return _NetworkManager_updateProtocolCacheDisabled2.apply(this, arguments);\n  }\n  return _NetworkManager_updateProtocolCacheDisabled;\n}(), _NetworkManager_onRequestWillBeSent = function _NetworkManager_onRequestWillBeSent(event) {\n  // Request interception doesn't happen for data URLs with Network Service.\n  if (__classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\") && !event.request.url.startsWith('data:')) {\n    const {\n      requestId: networkRequestId\n    } = event;\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").storeRequestWillBeSent(networkRequestId, event);\n    /**\n     * CDP may have sent a Fetch.requestPaused event already. Check for it.\n     */\n    const requestPausedEvent = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequestPaused(networkRequestId);\n    if (requestPausedEvent) {\n      const {\n        requestId: fetchRequestId\n      } = requestPausedEvent;\n      __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_patchRequestEventHeaders).call(this, event, requestPausedEvent);\n      __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, event, fetchRequestId);\n      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetRequestPaused(networkRequestId);\n    }\n    return;\n  }\n  __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, event, undefined);\n}, _NetworkManager_onAuthRequired = function _NetworkManager_onAuthRequired(event) {\n  let response = 'Default';\n  if (__classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, \"f\").has(event.requestId)) {\n    response = 'CancelAuth';\n  } else if (__classPrivateFieldGet(this, _NetworkManager_credentials, \"f\")) {\n    response = 'ProvideCredentials';\n    __classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, \"f\").add(event.requestId);\n  }\n  const {\n    username,\n    password\n  } = __classPrivateFieldGet(this, _NetworkManager_credentials, \"f\") || {\n    username: undefined,\n    password: undefined\n  };\n  __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Fetch.continueWithAuth', {\n    requestId: event.requestId,\n    authChallengeResponse: {\n      response,\n      username,\n      password\n    }\n  }).catch(debugError);\n}, _NetworkManager_onRequestPaused = function _NetworkManager_onRequestPaused(event) {\n  if (!__classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\") && __classPrivateFieldGet(this, _NetworkManager_protocolRequestInterceptionEnabled, \"f\")) {\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Fetch.continueRequest', {\n      requestId: event.requestId\n    }).catch(debugError);\n  }\n  const {\n    networkId: networkRequestId,\n    requestId: fetchRequestId\n  } = event;\n  if (!networkRequestId) {\n    return;\n  }\n  const requestWillBeSentEvent = (() => {\n    const requestWillBeSentEvent = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequestWillBeSent(networkRequestId);\n    // redirect requests have the same `requestId`,\n    if (requestWillBeSentEvent && (requestWillBeSentEvent.request.url !== event.request.url || requestWillBeSentEvent.request.method !== event.request.method)) {\n      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetRequestWillBeSent(networkRequestId);\n      return;\n    }\n    return requestWillBeSentEvent;\n  })();\n  if (requestWillBeSentEvent) {\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_patchRequestEventHeaders).call(this, requestWillBeSentEvent, event);\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, requestWillBeSentEvent, fetchRequestId);\n  } else {\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").storeRequestPaused(networkRequestId, event);\n  }\n}, _NetworkManager_patchRequestEventHeaders = function _NetworkManager_patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {\n  requestWillBeSentEvent.request.headers = {\n    ...requestWillBeSentEvent.request.headers,\n    // includes extra headers, like: Accept, Origin\n    ...requestPausedEvent.request.headers\n  };\n}, _NetworkManager_onRequest = function _NetworkManager_onRequest(event, fetchRequestId) {\n  let redirectChain = [];\n  if (event.redirectResponse) {\n    // We want to emit a response and requestfinished for the\n    // redirectResponse, but we can't do so unless we have a\n    // responseExtraInfo ready to pair it up with. If we don't have any\n    // responseExtraInfos saved in our queue, they we have to wait until\n    // the next one to emit response and requestfinished, *and* we should\n    // also wait to emit this Request too because it should come after the\n    // response/requestfinished.\n    let redirectResponseExtraInfo = null;\n    if (event.redirectHasExtraInfo) {\n      redirectResponseExtraInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(event.requestId).shift();\n      if (!redirectResponseExtraInfo) {\n        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").queueRedirectInfo(event.requestId, {\n          event,\n          fetchRequestId\n        });\n        return;\n      }\n    }\n    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n    // If we connect late to the target, we could have missed the\n    // requestWillBeSent event.\n    if (request) {\n      __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_handleRequestRedirect).call(this, request, event.redirectResponse, redirectResponseExtraInfo);\n      redirectChain = request._redirectChain;\n    }\n  }\n  const frame = event.frameId ? __classPrivateFieldGet(this, _NetworkManager_frameManager, \"f\").frame(event.frameId) : null;\n  const request = new HTTPRequest(__classPrivateFieldGet(this, _NetworkManager_client, \"f\"), frame, fetchRequestId, __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\"), event, redirectChain);\n  __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").storeRequest(event.requestId, request);\n  this.emit(NetworkManagerEmittedEvents.Request, request);\n  request.finalizeInterceptions();\n}, _NetworkManager_onRequestServedFromCache = function _NetworkManager_onRequestServedFromCache(event) {\n  const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n  if (request) {\n    request._fromMemoryCache = true;\n  }\n  this.emit(NetworkManagerEmittedEvents.RequestServedFromCache, request);\n}, _NetworkManager_handleRequestRedirect = function _NetworkManager_handleRequestRedirect(request, responsePayload, extraInfo) {\n  const response = new HTTPResponse(__classPrivateFieldGet(this, _NetworkManager_client, \"f\"), request, responsePayload, extraInfo);\n  request._response = response;\n  request._redirectChain.push(request);\n  response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n  __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_forgetRequest).call(this, request, false);\n  this.emit(NetworkManagerEmittedEvents.Response, response);\n  this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n}, _NetworkManager_emitResponseEvent = function _NetworkManager_emitResponseEvent(responseReceived, extraInfo) {\n  const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(responseReceived.requestId);\n  // FileUpload sends a response without a matching request.\n  if (!request) {\n    return;\n  }\n  const extraInfos = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(responseReceived.requestId);\n  if (extraInfos.length) {\n    debugError(new Error('Unexpected extraInfo events for request ' + responseReceived.requestId));\n  }\n  // Chromium sends wrong extraInfo events for responses served from cache.\n  // See https://github.com/puppeteer/puppeteer/issues/9965 and\n  // https://crbug.com/1340398.\n  if (responseReceived.response.fromDiskCache) {\n    extraInfo = null;\n  }\n  const response = new HTTPResponse(__classPrivateFieldGet(this, _NetworkManager_client, \"f\"), request, responseReceived.response, extraInfo);\n  request._response = response;\n  this.emit(NetworkManagerEmittedEvents.Response, response);\n}, _NetworkManager_onResponseReceived = function _NetworkManager_onResponseReceived(event) {\n  const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n  let extraInfo = null;\n  if (request && !request._fromMemoryCache && event.hasExtraInfo) {\n    extraInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(event.requestId).shift();\n    if (!extraInfo) {\n      // Wait until we get the corresponding ExtraInfo event.\n      __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").queueEventGroup(event.requestId, {\n        responseReceivedEvent: event\n      });\n      return;\n    }\n  }\n  __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitResponseEvent).call(this, event, extraInfo);\n}, _NetworkManager_onResponseReceivedExtraInfo = function _NetworkManager_onResponseReceivedExtraInfo(event) {\n  // We may have skipped a redirect response/request pair due to waiting for\n  // this ExtraInfo event. If so, continue that work now that we have the\n  // request.\n  const redirectInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").takeQueuedRedirectInfo(event.requestId);\n  if (redirectInfo) {\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(event.requestId).push(event);\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, redirectInfo.event, redirectInfo.fetchRequestId);\n    return;\n  }\n  // We may have skipped response and loading events because we didn't have\n  // this ExtraInfo event yet. If so, emit those events now.\n  const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getQueuedEventGroup(event.requestId);\n  if (queuedEvents) {\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetQueuedEventGroup(event.requestId);\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitResponseEvent).call(this, queuedEvents.responseReceivedEvent, event);\n    if (queuedEvents.loadingFinishedEvent) {\n      __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFinished).call(this, queuedEvents.loadingFinishedEvent);\n    }\n    if (queuedEvents.loadingFailedEvent) {\n      __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFailed).call(this, queuedEvents.loadingFailedEvent);\n    }\n    return;\n  }\n  // Wait until we get another event that can use this ExtraInfo event.\n  __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(event.requestId).push(event);\n}, _NetworkManager_forgetRequest = function _NetworkManager_forgetRequest(request, events) {\n  const requestId = request._requestId;\n  const interceptionId = request._interceptionId;\n  __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetRequest(requestId);\n  interceptionId !== undefined && __classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, \"f\").delete(interceptionId);\n  if (events) {\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forget(requestId);\n  }\n}, _NetworkManager_onLoadingFinished = function _NetworkManager_onLoadingFinished(event) {\n  // If the response event for this request is still waiting on a\n  // corresponding ExtraInfo event, then wait to emit this event too.\n  const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getQueuedEventGroup(event.requestId);\n  if (queuedEvents) {\n    queuedEvents.loadingFinishedEvent = event;\n  } else {\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFinished).call(this, event);\n  }\n}, _NetworkManager_emitLoadingFinished = function _NetworkManager_emitLoadingFinished(event) {\n  var _a;\n  const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n  // For certain requestIds we never receive requestWillBeSent event.\n  // @see https://crbug.com/750469\n  if (!request) {\n    return;\n  }\n  // Under certain conditions we never get the Network.responseReceived\n  // event from protocol. @see https://crbug.com/883475\n  if (request.response()) {\n    (_a = request.response()) === null || _a === void 0 ? void 0 : _a._resolveBody(null);\n  }\n  __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_forgetRequest).call(this, request, true);\n  this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n}, _NetworkManager_onLoadingFailed = function _NetworkManager_onLoadingFailed(event) {\n  // If the response event for this request is still waiting on a\n  // corresponding ExtraInfo event, then wait to emit this event too.\n  const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getQueuedEventGroup(event.requestId);\n  if (queuedEvents) {\n    queuedEvents.loadingFailedEvent = event;\n  } else {\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFailed).call(this, event);\n  }\n}, _NetworkManager_emitLoadingFailed = function _NetworkManager_emitLoadingFailed(event) {\n  const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n  // For certain requestIds we never receive requestWillBeSent event.\n  // @see https://crbug.com/750469\n  if (!request) {\n    return;\n  }\n  request._failureText = event.errorText;\n  const response = request.response();\n  if (response) {\n    response._resolveBody(null);\n  }\n  __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_forgetRequest).call(this, request, true);\n  this.emit(NetworkManagerEmittedEvents.RequestFailed, request);\n};","map":{"version":3,"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","_NetworkManager_instances","_NetworkManager_client","_NetworkManager_ignoreHTTPSErrors","_NetworkManager_frameManager","_NetworkManager_networkEventManager","_NetworkManager_extraHTTPHeaders","_NetworkManager_credentials","_NetworkManager_attemptedAuthentications","_NetworkManager_userRequestInterceptionEnabled","_NetworkManager_protocolRequestInterceptionEnabled","_NetworkManager_userCacheDisabled","_NetworkManager_emulatedNetworkConditions","_NetworkManager_deferredInitPromise","_NetworkManager_updateNetworkConditions","_NetworkManager_updateProtocolRequestInterception","_NetworkManager_cacheDisabled","_NetworkManager_updateProtocolCacheDisabled","_NetworkManager_onRequestWillBeSent","_NetworkManager_onAuthRequired","_NetworkManager_onRequestPaused","_NetworkManager_patchRequestEventHeaders","_NetworkManager_onRequest","_NetworkManager_onRequestServedFromCache","_NetworkManager_handleRequestRedirect","_NetworkManager_emitResponseEvent","_NetworkManager_onResponseReceived","_NetworkManager_onResponseReceivedExtraInfo","_NetworkManager_forgetRequest","_NetworkManager_onLoadingFinished","_NetworkManager_emitLoadingFinished","_NetworkManager_onLoadingFailed","_NetworkManager_emitLoadingFailed","assert","createDebuggableDeferredPromise","EventEmitter","HTTPRequest","HTTPResponse","NetworkEventManager","debugError","isString","NetworkManagerEmittedEvents","Request","Symbol","RequestServedFromCache","Response","RequestFailed","RequestFinished","NetworkManager","constructor","client","ignoreHTTPSErrors","frameManager","add","Set","offline","upload","download","latency","on","bind","initialize","init","Promise","all","send","ignore","deferredInitPromise","then","resolve","catch","err","reject","authenticate","credentials","setExtraHTTPHeaders","extraHTTPHeaders","key","Object","keys","toLowerCase","headers","assign","numRequestsInProgress","setOfflineMode","emulateNetworkConditions","networkConditions","setUserAgent","userAgent","userAgentMetadata","setCacheEnabled","enabled","setRequestInterception","WeakMap","WeakSet","uploadThroughput","downloadThroughput","handleAuthRequests","patterns","urlPattern","cacheDisabled","event","request","url","startsWith","requestId","networkRequestId","storeRequestWillBeSent","requestPausedEvent","getRequestPaused","fetchRequestId","forgetRequestPaused","undefined","response","username","password","authChallengeResponse","networkId","requestWillBeSentEvent","getRequestWillBeSent","method","forgetRequestWillBeSent","storeRequestPaused","redirectChain","redirectResponse","redirectResponseExtraInfo","redirectHasExtraInfo","responseExtraInfo","shift","queueRedirectInfo","getRequest","_redirectChain","frame","frameId","storeRequest","emit","finalizeInterceptions","_fromMemoryCache","responsePayload","extraInfo","_response","push","_resolveBody","Error","responseReceived","extraInfos","length","fromDiskCache","hasExtraInfo","queueEventGroup","responseReceivedEvent","redirectInfo","takeQueuedRedirectInfo","queuedEvents","getQueuedEventGroup","forgetQueuedEventGroup","loadingFinishedEvent","loadingFailedEvent","events","_requestId","interceptionId","_interceptionId","forgetRequest","delete","forget","_a","_failureText","errorText"],"sources":["/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManager.js"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _NetworkManager_instances, _NetworkManager_client, _NetworkManager_ignoreHTTPSErrors, _NetworkManager_frameManager, _NetworkManager_networkEventManager, _NetworkManager_extraHTTPHeaders, _NetworkManager_credentials, _NetworkManager_attemptedAuthentications, _NetworkManager_userRequestInterceptionEnabled, _NetworkManager_protocolRequestInterceptionEnabled, _NetworkManager_userCacheDisabled, _NetworkManager_emulatedNetworkConditions, _NetworkManager_deferredInitPromise, _NetworkManager_updateNetworkConditions, _NetworkManager_updateProtocolRequestInterception, _NetworkManager_cacheDisabled, _NetworkManager_updateProtocolCacheDisabled, _NetworkManager_onRequestWillBeSent, _NetworkManager_onAuthRequired, _NetworkManager_onRequestPaused, _NetworkManager_patchRequestEventHeaders, _NetworkManager_onRequest, _NetworkManager_onRequestServedFromCache, _NetworkManager_handleRequestRedirect, _NetworkManager_emitResponseEvent, _NetworkManager_onResponseReceived, _NetworkManager_onResponseReceivedExtraInfo, _NetworkManager_forgetRequest, _NetworkManager_onLoadingFinished, _NetworkManager_emitLoadingFinished, _NetworkManager_onLoadingFailed, _NetworkManager_emitLoadingFailed;\nimport { assert } from '../util/assert.js';\nimport { createDebuggableDeferredPromise } from '../util/DebuggableDeferredPromise.js';\nimport { EventEmitter } from './EventEmitter.js';\nimport { HTTPRequest } from './HTTPRequest.js';\nimport { HTTPResponse } from './HTTPResponse.js';\nimport { NetworkEventManager } from './NetworkEventManager.js';\nimport { debugError, isString } from './util.js';\n/**\n * We use symbols to prevent any external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\nexport const NetworkManagerEmittedEvents = {\n    Request: Symbol('NetworkManager.Request'),\n    RequestServedFromCache: Symbol('NetworkManager.RequestServedFromCache'),\n    Response: Symbol('NetworkManager.Response'),\n    RequestFailed: Symbol('NetworkManager.RequestFailed'),\n    RequestFinished: Symbol('NetworkManager.RequestFinished'),\n};\n/**\n * @internal\n */\nexport class NetworkManager extends EventEmitter {\n    constructor(client, ignoreHTTPSErrors, frameManager) {\n        super();\n        _NetworkManager_instances.add(this);\n        _NetworkManager_client.set(this, void 0);\n        _NetworkManager_ignoreHTTPSErrors.set(this, void 0);\n        _NetworkManager_frameManager.set(this, void 0);\n        _NetworkManager_networkEventManager.set(this, new NetworkEventManager());\n        _NetworkManager_extraHTTPHeaders.set(this, {});\n        _NetworkManager_credentials.set(this, void 0);\n        _NetworkManager_attemptedAuthentications.set(this, new Set());\n        _NetworkManager_userRequestInterceptionEnabled.set(this, false);\n        _NetworkManager_protocolRequestInterceptionEnabled.set(this, false);\n        _NetworkManager_userCacheDisabled.set(this, false);\n        _NetworkManager_emulatedNetworkConditions.set(this, {\n            offline: false,\n            upload: -1,\n            download: -1,\n            latency: 0,\n        });\n        _NetworkManager_deferredInitPromise.set(this, void 0);\n        __classPrivateFieldSet(this, _NetworkManager_client, client, \"f\");\n        __classPrivateFieldSet(this, _NetworkManager_ignoreHTTPSErrors, ignoreHTTPSErrors, \"f\");\n        __classPrivateFieldSet(this, _NetworkManager_frameManager, frameManager, \"f\");\n        __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Fetch.requestPaused', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequestPaused).bind(this));\n        __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Fetch.authRequired', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onAuthRequired).bind(this));\n        __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.requestWillBeSent', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequestWillBeSent).bind(this));\n        __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.requestServedFromCache', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequestServedFromCache).bind(this));\n        __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.responseReceived', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onResponseReceived).bind(this));\n        __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.loadingFinished', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onLoadingFinished).bind(this));\n        __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.loadingFailed', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onLoadingFailed).bind(this));\n        __classPrivateFieldGet(this, _NetworkManager_client, \"f\").on('Network.responseReceivedExtraInfo', __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onResponseReceivedExtraInfo).bind(this));\n    }\n    /**\n     * Initialize calls should avoid async dependencies between CDP calls as those\n     * might not resolve until after the target is resumed causing a deadlock.\n     */\n    initialize() {\n        if (__classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\")) {\n            return __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\");\n        }\n        __classPrivateFieldSet(this, _NetworkManager_deferredInitPromise, createDebuggableDeferredPromise('NetworkManager initialization timed out'), \"f\");\n        const init = Promise.all([\n            __classPrivateFieldGet(this, _NetworkManager_ignoreHTTPSErrors, \"f\")\n                ? __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Security.setIgnoreCertificateErrors', {\n                    ignore: true,\n                })\n                : null,\n            __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.enable'),\n        ]);\n        const deferredInitPromise = __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\");\n        init\n            .then(() => {\n            deferredInitPromise.resolve();\n        })\n            .catch(err => {\n            deferredInitPromise.reject(err);\n        });\n        return __classPrivateFieldGet(this, _NetworkManager_deferredInitPromise, \"f\");\n    }\n    async authenticate(credentials) {\n        __classPrivateFieldSet(this, _NetworkManager_credentials, credentials, \"f\");\n        await __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolRequestInterception).call(this);\n    }\n    async setExtraHTTPHeaders(extraHTTPHeaders) {\n        __classPrivateFieldSet(this, _NetworkManager_extraHTTPHeaders, {}, \"f\");\n        for (const key of Object.keys(extraHTTPHeaders)) {\n            const value = extraHTTPHeaders[key];\n            assert(isString(value), `Expected value of header \"${key}\" to be String, but \"${typeof value}\" is found.`);\n            __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, \"f\")[key.toLowerCase()] = value;\n        }\n        await __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.setExtraHTTPHeaders', {\n            headers: __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, \"f\"),\n        });\n    }\n    extraHTTPHeaders() {\n        return Object.assign({}, __classPrivateFieldGet(this, _NetworkManager_extraHTTPHeaders, \"f\"));\n    }\n    numRequestsInProgress() {\n        return __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").numRequestsInProgress();\n    }\n    async setOfflineMode(value) {\n        __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").offline = value;\n        await __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateNetworkConditions).call(this);\n    }\n    async emulateNetworkConditions(networkConditions) {\n        __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").upload = networkConditions\n            ? networkConditions.upload\n            : -1;\n        __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").download = networkConditions\n            ? networkConditions.download\n            : -1;\n        __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").latency = networkConditions\n            ? networkConditions.latency\n            : 0;\n        await __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateNetworkConditions).call(this);\n    }\n    async setUserAgent(userAgent, userAgentMetadata) {\n        await __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.setUserAgentOverride', {\n            userAgent: userAgent,\n            userAgentMetadata: userAgentMetadata,\n        });\n    }\n    async setCacheEnabled(enabled) {\n        __classPrivateFieldSet(this, _NetworkManager_userCacheDisabled, !enabled, \"f\");\n        await __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolCacheDisabled).call(this);\n    }\n    async setRequestInterception(value) {\n        __classPrivateFieldSet(this, _NetworkManager_userRequestInterceptionEnabled, value, \"f\");\n        await __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolRequestInterception).call(this);\n    }\n}\n_NetworkManager_client = new WeakMap(), _NetworkManager_ignoreHTTPSErrors = new WeakMap(), _NetworkManager_frameManager = new WeakMap(), _NetworkManager_networkEventManager = new WeakMap(), _NetworkManager_extraHTTPHeaders = new WeakMap(), _NetworkManager_credentials = new WeakMap(), _NetworkManager_attemptedAuthentications = new WeakMap(), _NetworkManager_userRequestInterceptionEnabled = new WeakMap(), _NetworkManager_protocolRequestInterceptionEnabled = new WeakMap(), _NetworkManager_userCacheDisabled = new WeakMap(), _NetworkManager_emulatedNetworkConditions = new WeakMap(), _NetworkManager_deferredInitPromise = new WeakMap(), _NetworkManager_instances = new WeakSet(), _NetworkManager_updateNetworkConditions = async function _NetworkManager_updateNetworkConditions() {\n    await __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.emulateNetworkConditions', {\n        offline: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").offline,\n        latency: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").latency,\n        uploadThroughput: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").upload,\n        downloadThroughput: __classPrivateFieldGet(this, _NetworkManager_emulatedNetworkConditions, \"f\").download,\n    });\n}, _NetworkManager_updateProtocolRequestInterception = async function _NetworkManager_updateProtocolRequestInterception() {\n    const enabled = __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\") || !!__classPrivateFieldGet(this, _NetworkManager_credentials, \"f\");\n    if (enabled === __classPrivateFieldGet(this, _NetworkManager_protocolRequestInterceptionEnabled, \"f\")) {\n        return;\n    }\n    __classPrivateFieldSet(this, _NetworkManager_protocolRequestInterceptionEnabled, enabled, \"f\");\n    if (enabled) {\n        await Promise.all([\n            __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolCacheDisabled).call(this),\n            __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Fetch.enable', {\n                handleAuthRequests: true,\n                patterns: [{ urlPattern: '*' }],\n            }),\n        ]);\n    }\n    else {\n        await Promise.all([\n            __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_updateProtocolCacheDisabled).call(this),\n            __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Fetch.disable'),\n        ]);\n    }\n}, _NetworkManager_cacheDisabled = function _NetworkManager_cacheDisabled() {\n    return __classPrivateFieldGet(this, _NetworkManager_userCacheDisabled, \"f\");\n}, _NetworkManager_updateProtocolCacheDisabled = async function _NetworkManager_updateProtocolCacheDisabled() {\n    await __classPrivateFieldGet(this, _NetworkManager_client, \"f\").send('Network.setCacheDisabled', {\n        cacheDisabled: __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_cacheDisabled).call(this),\n    });\n}, _NetworkManager_onRequestWillBeSent = function _NetworkManager_onRequestWillBeSent(event) {\n    // Request interception doesn't happen for data URLs with Network Service.\n    if (__classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\") &&\n        !event.request.url.startsWith('data:')) {\n        const { requestId: networkRequestId } = event;\n        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").storeRequestWillBeSent(networkRequestId, event);\n        /**\n         * CDP may have sent a Fetch.requestPaused event already. Check for it.\n         */\n        const requestPausedEvent = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequestPaused(networkRequestId);\n        if (requestPausedEvent) {\n            const { requestId: fetchRequestId } = requestPausedEvent;\n            __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_patchRequestEventHeaders).call(this, event, requestPausedEvent);\n            __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, event, fetchRequestId);\n            __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetRequestPaused(networkRequestId);\n        }\n        return;\n    }\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, event, undefined);\n}, _NetworkManager_onAuthRequired = function _NetworkManager_onAuthRequired(event) {\n    let response = 'Default';\n    if (__classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, \"f\").has(event.requestId)) {\n        response = 'CancelAuth';\n    }\n    else if (__classPrivateFieldGet(this, _NetworkManager_credentials, \"f\")) {\n        response = 'ProvideCredentials';\n        __classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, \"f\").add(event.requestId);\n    }\n    const { username, password } = __classPrivateFieldGet(this, _NetworkManager_credentials, \"f\") || {\n        username: undefined,\n        password: undefined,\n    };\n    __classPrivateFieldGet(this, _NetworkManager_client, \"f\")\n        .send('Fetch.continueWithAuth', {\n        requestId: event.requestId,\n        authChallengeResponse: { response, username, password },\n    })\n        .catch(debugError);\n}, _NetworkManager_onRequestPaused = function _NetworkManager_onRequestPaused(event) {\n    if (!__classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\") &&\n        __classPrivateFieldGet(this, _NetworkManager_protocolRequestInterceptionEnabled, \"f\")) {\n        __classPrivateFieldGet(this, _NetworkManager_client, \"f\")\n            .send('Fetch.continueRequest', {\n            requestId: event.requestId,\n        })\n            .catch(debugError);\n    }\n    const { networkId: networkRequestId, requestId: fetchRequestId } = event;\n    if (!networkRequestId) {\n        return;\n    }\n    const requestWillBeSentEvent = (() => {\n        const requestWillBeSentEvent = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequestWillBeSent(networkRequestId);\n        // redirect requests have the same `requestId`,\n        if (requestWillBeSentEvent &&\n            (requestWillBeSentEvent.request.url !== event.request.url ||\n                requestWillBeSentEvent.request.method !== event.request.method)) {\n            __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetRequestWillBeSent(networkRequestId);\n            return;\n        }\n        return requestWillBeSentEvent;\n    })();\n    if (requestWillBeSentEvent) {\n        __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_patchRequestEventHeaders).call(this, requestWillBeSentEvent, event);\n        __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, requestWillBeSentEvent, fetchRequestId);\n    }\n    else {\n        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").storeRequestPaused(networkRequestId, event);\n    }\n}, _NetworkManager_patchRequestEventHeaders = function _NetworkManager_patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {\n    requestWillBeSentEvent.request.headers = {\n        ...requestWillBeSentEvent.request.headers,\n        // includes extra headers, like: Accept, Origin\n        ...requestPausedEvent.request.headers,\n    };\n}, _NetworkManager_onRequest = function _NetworkManager_onRequest(event, fetchRequestId) {\n    let redirectChain = [];\n    if (event.redirectResponse) {\n        // We want to emit a response and requestfinished for the\n        // redirectResponse, but we can't do so unless we have a\n        // responseExtraInfo ready to pair it up with. If we don't have any\n        // responseExtraInfos saved in our queue, they we have to wait until\n        // the next one to emit response and requestfinished, *and* we should\n        // also wait to emit this Request too because it should come after the\n        // response/requestfinished.\n        let redirectResponseExtraInfo = null;\n        if (event.redirectHasExtraInfo) {\n            redirectResponseExtraInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\")\n                .responseExtraInfo(event.requestId)\n                .shift();\n            if (!redirectResponseExtraInfo) {\n                __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").queueRedirectInfo(event.requestId, {\n                    event,\n                    fetchRequestId,\n                });\n                return;\n            }\n        }\n        const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n        // If we connect late to the target, we could have missed the\n        // requestWillBeSent event.\n        if (request) {\n            __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_handleRequestRedirect).call(this, request, event.redirectResponse, redirectResponseExtraInfo);\n            redirectChain = request._redirectChain;\n        }\n    }\n    const frame = event.frameId\n        ? __classPrivateFieldGet(this, _NetworkManager_frameManager, \"f\").frame(event.frameId)\n        : null;\n    const request = new HTTPRequest(__classPrivateFieldGet(this, _NetworkManager_client, \"f\"), frame, fetchRequestId, __classPrivateFieldGet(this, _NetworkManager_userRequestInterceptionEnabled, \"f\"), event, redirectChain);\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").storeRequest(event.requestId, request);\n    this.emit(NetworkManagerEmittedEvents.Request, request);\n    request.finalizeInterceptions();\n}, _NetworkManager_onRequestServedFromCache = function _NetworkManager_onRequestServedFromCache(event) {\n    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n    if (request) {\n        request._fromMemoryCache = true;\n    }\n    this.emit(NetworkManagerEmittedEvents.RequestServedFromCache, request);\n}, _NetworkManager_handleRequestRedirect = function _NetworkManager_handleRequestRedirect(request, responsePayload, extraInfo) {\n    const response = new HTTPResponse(__classPrivateFieldGet(this, _NetworkManager_client, \"f\"), request, responsePayload, extraInfo);\n    request._response = response;\n    request._redirectChain.push(request);\n    response._resolveBody(new Error('Response body is unavailable for redirect responses'));\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_forgetRequest).call(this, request, false);\n    this.emit(NetworkManagerEmittedEvents.Response, response);\n    this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n}, _NetworkManager_emitResponseEvent = function _NetworkManager_emitResponseEvent(responseReceived, extraInfo) {\n    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(responseReceived.requestId);\n    // FileUpload sends a response without a matching request.\n    if (!request) {\n        return;\n    }\n    const extraInfos = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(responseReceived.requestId);\n    if (extraInfos.length) {\n        debugError(new Error('Unexpected extraInfo events for request ' +\n            responseReceived.requestId));\n    }\n    // Chromium sends wrong extraInfo events for responses served from cache.\n    // See https://github.com/puppeteer/puppeteer/issues/9965 and\n    // https://crbug.com/1340398.\n    if (responseReceived.response.fromDiskCache) {\n        extraInfo = null;\n    }\n    const response = new HTTPResponse(__classPrivateFieldGet(this, _NetworkManager_client, \"f\"), request, responseReceived.response, extraInfo);\n    request._response = response;\n    this.emit(NetworkManagerEmittedEvents.Response, response);\n}, _NetworkManager_onResponseReceived = function _NetworkManager_onResponseReceived(event) {\n    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n    let extraInfo = null;\n    if (request && !request._fromMemoryCache && event.hasExtraInfo) {\n        extraInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\")\n            .responseExtraInfo(event.requestId)\n            .shift();\n        if (!extraInfo) {\n            // Wait until we get the corresponding ExtraInfo event.\n            __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").queueEventGroup(event.requestId, {\n                responseReceivedEvent: event,\n            });\n            return;\n        }\n    }\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitResponseEvent).call(this, event, extraInfo);\n}, _NetworkManager_onResponseReceivedExtraInfo = function _NetworkManager_onResponseReceivedExtraInfo(event) {\n    // We may have skipped a redirect response/request pair due to waiting for\n    // this ExtraInfo event. If so, continue that work now that we have the\n    // request.\n    const redirectInfo = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").takeQueuedRedirectInfo(event.requestId);\n    if (redirectInfo) {\n        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(event.requestId).push(event);\n        __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_onRequest).call(this, redirectInfo.event, redirectInfo.fetchRequestId);\n        return;\n    }\n    // We may have skipped response and loading events because we didn't have\n    // this ExtraInfo event yet. If so, emit those events now.\n    const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getQueuedEventGroup(event.requestId);\n    if (queuedEvents) {\n        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetQueuedEventGroup(event.requestId);\n        __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitResponseEvent).call(this, queuedEvents.responseReceivedEvent, event);\n        if (queuedEvents.loadingFinishedEvent) {\n            __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFinished).call(this, queuedEvents.loadingFinishedEvent);\n        }\n        if (queuedEvents.loadingFailedEvent) {\n            __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFailed).call(this, queuedEvents.loadingFailedEvent);\n        }\n        return;\n    }\n    // Wait until we get another event that can use this ExtraInfo event.\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").responseExtraInfo(event.requestId).push(event);\n}, _NetworkManager_forgetRequest = function _NetworkManager_forgetRequest(request, events) {\n    const requestId = request._requestId;\n    const interceptionId = request._interceptionId;\n    __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forgetRequest(requestId);\n    interceptionId !== undefined &&\n        __classPrivateFieldGet(this, _NetworkManager_attemptedAuthentications, \"f\").delete(interceptionId);\n    if (events) {\n        __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").forget(requestId);\n    }\n}, _NetworkManager_onLoadingFinished = function _NetworkManager_onLoadingFinished(event) {\n    // If the response event for this request is still waiting on a\n    // corresponding ExtraInfo event, then wait to emit this event too.\n    const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getQueuedEventGroup(event.requestId);\n    if (queuedEvents) {\n        queuedEvents.loadingFinishedEvent = event;\n    }\n    else {\n        __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFinished).call(this, event);\n    }\n}, _NetworkManager_emitLoadingFinished = function _NetworkManager_emitLoadingFinished(event) {\n    var _a;\n    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) {\n        return;\n    }\n    // Under certain conditions we never get the Network.responseReceived\n    // event from protocol. @see https://crbug.com/883475\n    if (request.response()) {\n        (_a = request.response()) === null || _a === void 0 ? void 0 : _a._resolveBody(null);\n    }\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_forgetRequest).call(this, request, true);\n    this.emit(NetworkManagerEmittedEvents.RequestFinished, request);\n}, _NetworkManager_onLoadingFailed = function _NetworkManager_onLoadingFailed(event) {\n    // If the response event for this request is still waiting on a\n    // corresponding ExtraInfo event, then wait to emit this event too.\n    const queuedEvents = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getQueuedEventGroup(event.requestId);\n    if (queuedEvents) {\n        queuedEvents.loadingFailedEvent = event;\n    }\n    else {\n        __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_emitLoadingFailed).call(this, event);\n    }\n}, _NetworkManager_emitLoadingFailed = function _NetworkManager_emitLoadingFailed(event) {\n    const request = __classPrivateFieldGet(this, _NetworkManager_networkEventManager, \"f\").getRequest(event.requestId);\n    // For certain requestIds we never receive requestWillBeSent event.\n    // @see https://crbug.com/750469\n    if (!request) {\n        return;\n    }\n    request._failureText = event.errorText;\n    const response = request.response();\n    if (response) {\n        response._resolveBody(null);\n    }\n    __classPrivateFieldGet(this, _NetworkManager_instances, \"m\", _NetworkManager_forgetRequest).call(this, request, true);\n    this.emit(NetworkManagerEmittedEvents.RequestFailed, request);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}