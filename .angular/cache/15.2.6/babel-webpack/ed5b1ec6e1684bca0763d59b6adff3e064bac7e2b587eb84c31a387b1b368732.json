{"ast":null,"code":"import { TimeoutError } from '../common/Errors.js';\n/**\n * Creates and returns a promise along with the resolve/reject functions.\n *\n * If the promise has not been resolved/rejected within the `timeout` period,\n * the promise gets rejected with a timeout error. `timeout` has to be greater than 0 or\n * it is ignored.\n *\n * @internal\n */\nexport function createDeferredPromise(opts) {\n  let isResolved = false;\n  let isRejected = false;\n  let resolver;\n  let rejector;\n  const taskPromise = new Promise((resolve, reject) => {\n    resolver = resolve;\n    rejector = reject;\n  });\n  const timeoutId = opts && opts.timeout > 0 ? setTimeout(() => {\n    isRejected = true;\n    rejector(new TimeoutError(opts.message));\n  }, opts.timeout) : undefined;\n  return Object.assign(taskPromise, {\n    resolved: () => {\n      return isResolved;\n    },\n    finished: () => {\n      return isResolved || isRejected;\n    },\n    resolve: value => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n      isResolved = true;\n      resolver(value);\n    },\n    reject: err => {\n      clearTimeout(timeoutId);\n      isRejected = true;\n      rejector(err);\n    }\n  });\n}","map":{"version":3,"names":["TimeoutError","createDeferredPromise","opts","isResolved","isRejected","resolver","rejector","taskPromise","Promise","resolve","reject","timeoutId","timeout","setTimeout","message","undefined","Object","assign","resolved","finished","value","clearTimeout","err"],"sources":["/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/puppeteer-core/lib/esm/puppeteer/util/DeferredPromise.js"],"sourcesContent":["import { TimeoutError } from '../common/Errors.js';\n/**\n * Creates and returns a promise along with the resolve/reject functions.\n *\n * If the promise has not been resolved/rejected within the `timeout` period,\n * the promise gets rejected with a timeout error. `timeout` has to be greater than 0 or\n * it is ignored.\n *\n * @internal\n */\nexport function createDeferredPromise(opts) {\n    let isResolved = false;\n    let isRejected = false;\n    let resolver;\n    let rejector;\n    const taskPromise = new Promise((resolve, reject) => {\n        resolver = resolve;\n        rejector = reject;\n    });\n    const timeoutId = opts && opts.timeout > 0\n        ? setTimeout(() => {\n            isRejected = true;\n            rejector(new TimeoutError(opts.message));\n        }, opts.timeout)\n        : undefined;\n    return Object.assign(taskPromise, {\n        resolved: () => {\n            return isResolved;\n        },\n        finished: () => {\n            return isResolved || isRejected;\n        },\n        resolve: (value) => {\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n            isResolved = true;\n            resolver(value);\n        },\n        reject: (err) => {\n            clearTimeout(timeoutId);\n            isRejected = true;\n            rejector(err);\n        },\n    });\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,qBAAqB,CAACC,IAAI,EAAE;EACxC,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIC,UAAU,GAAG,KAAK;EACtB,IAAIC,QAAQ;EACZ,IAAIC,QAAQ;EACZ,MAAMC,WAAW,GAAG,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACjDL,QAAQ,GAAGI,OAAO;IAClBH,QAAQ,GAAGI,MAAM;EACrB,CAAC,CAAC;EACF,MAAMC,SAAS,GAAGT,IAAI,IAAIA,IAAI,CAACU,OAAO,GAAG,CAAC,GACpCC,UAAU,CAAC,MAAM;IACfT,UAAU,GAAG,IAAI;IACjBE,QAAQ,CAAC,IAAIN,YAAY,CAACE,IAAI,CAACY,OAAO,CAAC,CAAC;EAC5C,CAAC,EAAEZ,IAAI,CAACU,OAAO,CAAC,GACdG,SAAS;EACf,OAAOC,MAAM,CAACC,MAAM,CAACV,WAAW,EAAE;IAC9BW,QAAQ,EAAE,MAAM;MACZ,OAAOf,UAAU;IACrB,CAAC;IACDgB,QAAQ,EAAE,MAAM;MACZ,OAAOhB,UAAU,IAAIC,UAAU;IACnC,CAAC;IACDK,OAAO,EAAGW,KAAK,IAAK;MAChB,IAAIT,SAAS,EAAE;QACXU,YAAY,CAACV,SAAS,CAAC;MAC3B;MACAR,UAAU,GAAG,IAAI;MACjBE,QAAQ,CAACe,KAAK,CAAC;IACnB,CAAC;IACDV,MAAM,EAAGY,GAAG,IAAK;MACbD,YAAY,CAACV,SAAS,CAAC;MACvBP,UAAU,GAAG,IAAI;MACjBE,QAAQ,CAACgB,GAAG,CAAC;IACjB;EACJ,CAAC,CAAC;AACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}