{"ast":null,"code":"import _asyncToGenerator from \"/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isNode } from '../environment.js';\nimport { assert } from '../util/assert.js';\nimport { isErrorLike } from '../util/ErrorLike.js';\nimport { CDPBrowser } from './Browser.js';\nimport { Connection } from './Connection.js';\nimport { getFetch } from './fetch.js';\nimport { debugError } from './util.js';\nconst getWebSocketTransportClass = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* () {\n    return isNode ? (yield import('./NodeWebSocketTransport.js')).NodeWebSocketTransport : (yield import('./BrowserWebSocketTransport.js')).BrowserWebSocketTransport;\n  });\n  return function getWebSocketTransportClass() {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Users should never call this directly; it's called when calling\n * `puppeteer.connect`.\n *\n * @internal\n */\nexport function _connectToCDPBrowser(_x) {\n  return _connectToCDPBrowser2.apply(this, arguments);\n}\nfunction _connectToCDPBrowser2() {\n  _connectToCDPBrowser2 = _asyncToGenerator(function* (options) {\n    const {\n      browserWSEndpoint,\n      browserURL,\n      ignoreHTTPSErrors = false,\n      defaultViewport = {\n        width: 800,\n        height: 600\n      },\n      transport,\n      headers = {},\n      slowMo = 0,\n      targetFilter,\n      _isPageTarget: isPageTarget,\n      protocolTimeout\n    } = options;\n    assert(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, 'Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect');\n    let connection;\n    if (transport) {\n      connection = new Connection('', transport, slowMo, protocolTimeout);\n    } else if (browserWSEndpoint) {\n      const WebSocketClass = yield getWebSocketTransportClass();\n      const connectionTransport = yield WebSocketClass.create(browserWSEndpoint, headers);\n      connection = new Connection(browserWSEndpoint, connectionTransport, slowMo, protocolTimeout);\n    } else if (browserURL) {\n      const connectionURL = yield getWSEndpoint(browserURL);\n      const WebSocketClass = yield getWebSocketTransportClass();\n      const connectionTransport = yield WebSocketClass.create(connectionURL);\n      connection = new Connection(connectionURL, connectionTransport, slowMo, protocolTimeout);\n    }\n    const version = yield connection.send('Browser.getVersion');\n    const product = version.product.toLowerCase().includes('firefox') ? 'firefox' : 'chrome';\n    const {\n      browserContextIds\n    } = yield connection.send('Target.getBrowserContexts');\n    const browser = yield CDPBrowser._create(product || 'chrome', connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, undefined, () => {\n      return connection.send('Browser.close').catch(debugError);\n    }, targetFilter, isPageTarget);\n    return browser;\n  });\n  return _connectToCDPBrowser2.apply(this, arguments);\n}\nfunction getWSEndpoint(_x2) {\n  return _getWSEndpoint.apply(this, arguments);\n}\nfunction _getWSEndpoint() {\n  _getWSEndpoint = _asyncToGenerator(function* (browserURL) {\n    const endpointURL = new URL('/json/version', browserURL);\n    const fetch = yield getFetch();\n    try {\n      const result = yield fetch(endpointURL.toString(), {\n        method: 'GET'\n      });\n      if (!result.ok) {\n        throw new Error(`HTTP ${result.statusText}`);\n      }\n      const data = yield result.json();\n      return data.webSocketDebuggerUrl;\n    } catch (error) {\n      if (isErrorLike(error)) {\n        error.message = `Failed to fetch browser webSocket URL from ${endpointURL}: ` + error.message;\n      }\n      throw error;\n    }\n  });\n  return _getWSEndpoint.apply(this, arguments);\n}","map":{"version":3,"names":["isNode","assert","isErrorLike","CDPBrowser","Connection","getFetch","debugError","getWebSocketTransportClass","NodeWebSocketTransport","BrowserWebSocketTransport","_connectToCDPBrowser","options","browserWSEndpoint","browserURL","ignoreHTTPSErrors","defaultViewport","width","height","transport","headers","slowMo","targetFilter","_isPageTarget","isPageTarget","protocolTimeout","Number","connection","WebSocketClass","connectionTransport","create","connectionURL","getWSEndpoint","version","send","product","toLowerCase","includes","browserContextIds","browser","_create","undefined","catch","endpointURL","URL","fetch","result","toString","method","ok","Error","statusText","data","json","webSocketDebuggerUrl","error","message"],"sources":["/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserConnector.js"],"sourcesContent":["/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isNode } from '../environment.js';\nimport { assert } from '../util/assert.js';\nimport { isErrorLike } from '../util/ErrorLike.js';\nimport { CDPBrowser } from './Browser.js';\nimport { Connection } from './Connection.js';\nimport { getFetch } from './fetch.js';\nimport { debugError } from './util.js';\nconst getWebSocketTransportClass = async () => {\n    return isNode\n        ? (await import('./NodeWebSocketTransport.js')).NodeWebSocketTransport\n        : (await import('./BrowserWebSocketTransport.js'))\n            .BrowserWebSocketTransport;\n};\n/**\n * Users should never call this directly; it's called when calling\n * `puppeteer.connect`.\n *\n * @internal\n */\nexport async function _connectToCDPBrowser(options) {\n    const { browserWSEndpoint, browserURL, ignoreHTTPSErrors = false, defaultViewport = { width: 800, height: 600 }, transport, headers = {}, slowMo = 0, targetFilter, _isPageTarget: isPageTarget, protocolTimeout, } = options;\n    assert(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) ===\n        1, 'Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect');\n    let connection;\n    if (transport) {\n        connection = new Connection('', transport, slowMo, protocolTimeout);\n    }\n    else if (browserWSEndpoint) {\n        const WebSocketClass = await getWebSocketTransportClass();\n        const connectionTransport = await WebSocketClass.create(browserWSEndpoint, headers);\n        connection = new Connection(browserWSEndpoint, connectionTransport, slowMo, protocolTimeout);\n    }\n    else if (browserURL) {\n        const connectionURL = await getWSEndpoint(browserURL);\n        const WebSocketClass = await getWebSocketTransportClass();\n        const connectionTransport = await WebSocketClass.create(connectionURL);\n        connection = new Connection(connectionURL, connectionTransport, slowMo, protocolTimeout);\n    }\n    const version = await connection.send('Browser.getVersion');\n    const product = version.product.toLowerCase().includes('firefox')\n        ? 'firefox'\n        : 'chrome';\n    const { browserContextIds } = await connection.send('Target.getBrowserContexts');\n    const browser = await CDPBrowser._create(product || 'chrome', connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, undefined, () => {\n        return connection.send('Browser.close').catch(debugError);\n    }, targetFilter, isPageTarget);\n    return browser;\n}\nasync function getWSEndpoint(browserURL) {\n    const endpointURL = new URL('/json/version', browserURL);\n    const fetch = await getFetch();\n    try {\n        const result = await fetch(endpointURL.toString(), {\n            method: 'GET',\n        });\n        if (!result.ok) {\n            throw new Error(`HTTP ${result.statusText}`);\n        }\n        const data = await result.json();\n        return data.webSocketDebuggerUrl;\n    }\n    catch (error) {\n        if (isErrorLike(error)) {\n            error.message =\n                `Failed to fetch browser webSocket URL from ${endpointURL}: ` +\n                    error.message;\n        }\n        throw error;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}