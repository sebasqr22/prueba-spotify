{"ast":null,"code":"import _asyncToGenerator from \"/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Coverage_jsCoverage, _Coverage_cssCoverage, _JSCoverage_instances, _JSCoverage_client, _JSCoverage_enabled, _JSCoverage_scriptURLs, _JSCoverage_scriptSources, _JSCoverage_eventListeners, _JSCoverage_resetOnNavigation, _JSCoverage_reportAnonymousScripts, _JSCoverage_includeRawScriptCoverage, _JSCoverage_onExecutionContextsCleared, _JSCoverage_onScriptParsed, _CSSCoverage_instances, _CSSCoverage_client, _CSSCoverage_enabled, _CSSCoverage_stylesheetURLs, _CSSCoverage_stylesheetSources, _CSSCoverage_eventListeners, _CSSCoverage_resetOnNavigation, _CSSCoverage_onExecutionContextsCleared, _CSSCoverage_onStyleSheet;\nimport { assert } from '../util/assert.js';\nimport { EVALUATION_SCRIPT_URL } from './ExecutionContext.js';\nimport { addEventListener, debugError } from './util.js';\nimport { removeEventListeners } from './util.js';\n/**\n * The Coverage class provides methods to gather information about parts of\n * JavaScript and CSS that were used by the page.\n *\n * @remarks\n * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},\n * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.\n *\n * @example\n * An example of using JavaScript and CSS coverage to get percentage of initially\n * executed code:\n *\n * ```ts\n * // Enable both JavaScript and CSS coverage\n * await Promise.all([\n *   page.coverage.startJSCoverage(),\n *   page.coverage.startCSSCoverage(),\n * ]);\n * // Navigate to page\n * await page.goto('https://example.com');\n * // Disable both JavaScript and CSS coverage\n * const [jsCoverage, cssCoverage] = await Promise.all([\n *   page.coverage.stopJSCoverage(),\n *   page.coverage.stopCSSCoverage(),\n * ]);\n * let totalBytes = 0;\n * let usedBytes = 0;\n * const coverage = [...jsCoverage, ...cssCoverage];\n * for (const entry of coverage) {\n *   totalBytes += entry.text.length;\n *   for (const range of entry.ranges) usedBytes += range.end - range.start - 1;\n * }\n * console.log(`Bytes used: ${(usedBytes / totalBytes) * 100}%`);\n * ```\n *\n * @public\n */\nexport class Coverage {\n  constructor(client) {\n    _Coverage_jsCoverage.set(this, void 0);\n    _Coverage_cssCoverage.set(this, void 0);\n    __classPrivateFieldSet(this, _Coverage_jsCoverage, new JSCoverage(client), \"f\");\n    __classPrivateFieldSet(this, _Coverage_cssCoverage, new CSSCoverage(client), \"f\");\n  }\n  /**\n   * @param options - Set of configurable options for coverage defaults to\n   * `resetOnNavigation : true, reportAnonymousScripts : false,`\n   * `includeRawScriptCoverage : false, useBlockCoverage : true`\n   * @returns Promise that resolves when coverage is started.\n   *\n   * @remarks\n   * Anonymous scripts are ones that don't have an associated url. These are\n   * scripts that are dynamically created on the page using `eval` or\n   * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous\n   * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL\n   * comment is present, in which case that will the be URL).\n   */\n  startJSCoverage(options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return yield __classPrivateFieldGet(_this, _Coverage_jsCoverage, \"f\").start(options);\n    })();\n  }\n  /**\n   * Promise that resolves to the array of coverage reports for\n   * all scripts.\n   *\n   * @remarks\n   * JavaScript Coverage doesn't include anonymous scripts by default.\n   * However, scripts with sourceURLs are reported.\n   */\n  stopJSCoverage() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return yield __classPrivateFieldGet(_this2, _Coverage_jsCoverage, \"f\").stop();\n    })();\n  }\n  /**\n   * @param options - Set of configurable options for coverage, defaults to\n   * `resetOnNavigation : true`\n   * @returns Promise that resolves when coverage is started.\n   */\n  startCSSCoverage(options = {}) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return yield __classPrivateFieldGet(_this3, _Coverage_cssCoverage, \"f\").start(options);\n    })();\n  }\n  /**\n   * Promise that resolves to the array of coverage reports\n   * for all stylesheets.\n   *\n   * @remarks\n   * CSS Coverage doesn't include dynamically injected style tags\n   * without sourceURLs.\n   */\n  stopCSSCoverage() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return yield __classPrivateFieldGet(_this4, _Coverage_cssCoverage, \"f\").stop();\n    })();\n  }\n}\n_Coverage_jsCoverage = new WeakMap(), _Coverage_cssCoverage = new WeakMap();\n/**\n * @public\n */\nexport class JSCoverage {\n  constructor(client) {\n    _JSCoverage_instances.add(this);\n    _JSCoverage_client.set(this, void 0);\n    _JSCoverage_enabled.set(this, false);\n    _JSCoverage_scriptURLs.set(this, new Map());\n    _JSCoverage_scriptSources.set(this, new Map());\n    _JSCoverage_eventListeners.set(this, []);\n    _JSCoverage_resetOnNavigation.set(this, false);\n    _JSCoverage_reportAnonymousScripts.set(this, false);\n    _JSCoverage_includeRawScriptCoverage.set(this, false);\n    __classPrivateFieldSet(this, _JSCoverage_client, client, \"f\");\n  }\n  start(options = {}) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      assert(!__classPrivateFieldGet(_this5, _JSCoverage_enabled, \"f\"), 'JSCoverage is already enabled');\n      const {\n        resetOnNavigation = true,\n        reportAnonymousScripts = false,\n        includeRawScriptCoverage = false,\n        useBlockCoverage = true\n      } = options;\n      __classPrivateFieldSet(_this5, _JSCoverage_resetOnNavigation, resetOnNavigation, \"f\");\n      __classPrivateFieldSet(_this5, _JSCoverage_reportAnonymousScripts, reportAnonymousScripts, \"f\");\n      __classPrivateFieldSet(_this5, _JSCoverage_includeRawScriptCoverage, includeRawScriptCoverage, \"f\");\n      __classPrivateFieldSet(_this5, _JSCoverage_enabled, true, \"f\");\n      __classPrivateFieldGet(_this5, _JSCoverage_scriptURLs, \"f\").clear();\n      __classPrivateFieldGet(_this5, _JSCoverage_scriptSources, \"f\").clear();\n      __classPrivateFieldSet(_this5, _JSCoverage_eventListeners, [addEventListener(__classPrivateFieldGet(_this5, _JSCoverage_client, \"f\"), 'Debugger.scriptParsed', __classPrivateFieldGet(_this5, _JSCoverage_instances, \"m\", _JSCoverage_onScriptParsed).bind(_this5)), addEventListener(__classPrivateFieldGet(_this5, _JSCoverage_client, \"f\"), 'Runtime.executionContextsCleared', __classPrivateFieldGet(_this5, _JSCoverage_instances, \"m\", _JSCoverage_onExecutionContextsCleared).bind(_this5))], \"f\");\n      yield Promise.all([__classPrivateFieldGet(_this5, _JSCoverage_client, \"f\").send('Profiler.enable'), __classPrivateFieldGet(_this5, _JSCoverage_client, \"f\").send('Profiler.startPreciseCoverage', {\n        callCount: __classPrivateFieldGet(_this5, _JSCoverage_includeRawScriptCoverage, \"f\"),\n        detailed: useBlockCoverage\n      }), __classPrivateFieldGet(_this5, _JSCoverage_client, \"f\").send('Debugger.enable'), __classPrivateFieldGet(_this5, _JSCoverage_client, \"f\").send('Debugger.setSkipAllPauses', {\n        skip: true\n      })]);\n    })();\n  }\n  stop() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      assert(__classPrivateFieldGet(_this6, _JSCoverage_enabled, \"f\"), 'JSCoverage is not enabled');\n      __classPrivateFieldSet(_this6, _JSCoverage_enabled, false, \"f\");\n      const result = yield Promise.all([__classPrivateFieldGet(_this6, _JSCoverage_client, \"f\").send('Profiler.takePreciseCoverage'), __classPrivateFieldGet(_this6, _JSCoverage_client, \"f\").send('Profiler.stopPreciseCoverage'), __classPrivateFieldGet(_this6, _JSCoverage_client, \"f\").send('Profiler.disable'), __classPrivateFieldGet(_this6, _JSCoverage_client, \"f\").send('Debugger.disable')]);\n      removeEventListeners(__classPrivateFieldGet(_this6, _JSCoverage_eventListeners, \"f\"));\n      const coverage = [];\n      const profileResponse = result[0];\n      for (const entry of profileResponse.result) {\n        let url = __classPrivateFieldGet(_this6, _JSCoverage_scriptURLs, \"f\").get(entry.scriptId);\n        if (!url && __classPrivateFieldGet(_this6, _JSCoverage_reportAnonymousScripts, \"f\")) {\n          url = 'debugger://VM' + entry.scriptId;\n        }\n        const text = __classPrivateFieldGet(_this6, _JSCoverage_scriptSources, \"f\").get(entry.scriptId);\n        if (text === undefined || url === undefined) {\n          continue;\n        }\n        const flattenRanges = [];\n        for (const func of entry.functions) {\n          flattenRanges.push(...func.ranges);\n        }\n        const ranges = convertToDisjointRanges(flattenRanges);\n        if (!__classPrivateFieldGet(_this6, _JSCoverage_includeRawScriptCoverage, \"f\")) {\n          coverage.push({\n            url,\n            ranges,\n            text\n          });\n        } else {\n          coverage.push({\n            url,\n            ranges,\n            text,\n            rawScriptCoverage: entry\n          });\n        }\n      }\n      return coverage;\n    })();\n  }\n}\n_JSCoverage_client = new WeakMap(), _JSCoverage_enabled = new WeakMap(), _JSCoverage_scriptURLs = new WeakMap(), _JSCoverage_scriptSources = new WeakMap(), _JSCoverage_eventListeners = new WeakMap(), _JSCoverage_resetOnNavigation = new WeakMap(), _JSCoverage_reportAnonymousScripts = new WeakMap(), _JSCoverage_includeRawScriptCoverage = new WeakMap(), _JSCoverage_instances = new WeakSet(), _JSCoverage_onExecutionContextsCleared = function _JSCoverage_onExecutionContextsCleared() {\n  if (!__classPrivateFieldGet(this, _JSCoverage_resetOnNavigation, \"f\")) {\n    return;\n  }\n  __classPrivateFieldGet(this, _JSCoverage_scriptURLs, \"f\").clear();\n  __classPrivateFieldGet(this, _JSCoverage_scriptSources, \"f\").clear();\n}, _JSCoverage_onScriptParsed = /*#__PURE__*/function () {\n  var _JSCoverage_onScriptParsed2 = _asyncToGenerator(function* (event) {\n    // Ignore puppeteer-injected scripts\n    if (event.url === EVALUATION_SCRIPT_URL) {\n      return;\n    }\n    // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n    if (!event.url && !__classPrivateFieldGet(this, _JSCoverage_reportAnonymousScripts, \"f\")) {\n      return;\n    }\n    try {\n      const response = yield __classPrivateFieldGet(this, _JSCoverage_client, \"f\").send('Debugger.getScriptSource', {\n        scriptId: event.scriptId\n      });\n      __classPrivateFieldGet(this, _JSCoverage_scriptURLs, \"f\").set(event.scriptId, event.url);\n      __classPrivateFieldGet(this, _JSCoverage_scriptSources, \"f\").set(event.scriptId, response.scriptSource);\n    } catch (error) {\n      // This might happen if the page has already navigated away.\n      debugError(error);\n    }\n  });\n  function _JSCoverage_onScriptParsed(_x) {\n    return _JSCoverage_onScriptParsed2.apply(this, arguments);\n  }\n  return _JSCoverage_onScriptParsed;\n}();\n/**\n * @public\n */\nexport class CSSCoverage {\n  constructor(client) {\n    _CSSCoverage_instances.add(this);\n    _CSSCoverage_client.set(this, void 0);\n    _CSSCoverage_enabled.set(this, false);\n    _CSSCoverage_stylesheetURLs.set(this, new Map());\n    _CSSCoverage_stylesheetSources.set(this, new Map());\n    _CSSCoverage_eventListeners.set(this, []);\n    _CSSCoverage_resetOnNavigation.set(this, false);\n    __classPrivateFieldSet(this, _CSSCoverage_client, client, \"f\");\n  }\n  start(options = {}) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      assert(!__classPrivateFieldGet(_this7, _CSSCoverage_enabled, \"f\"), 'CSSCoverage is already enabled');\n      const {\n        resetOnNavigation = true\n      } = options;\n      __classPrivateFieldSet(_this7, _CSSCoverage_resetOnNavigation, resetOnNavigation, \"f\");\n      __classPrivateFieldSet(_this7, _CSSCoverage_enabled, true, \"f\");\n      __classPrivateFieldGet(_this7, _CSSCoverage_stylesheetURLs, \"f\").clear();\n      __classPrivateFieldGet(_this7, _CSSCoverage_stylesheetSources, \"f\").clear();\n      __classPrivateFieldSet(_this7, _CSSCoverage_eventListeners, [addEventListener(__classPrivateFieldGet(_this7, _CSSCoverage_client, \"f\"), 'CSS.styleSheetAdded', __classPrivateFieldGet(_this7, _CSSCoverage_instances, \"m\", _CSSCoverage_onStyleSheet).bind(_this7)), addEventListener(__classPrivateFieldGet(_this7, _CSSCoverage_client, \"f\"), 'Runtime.executionContextsCleared', __classPrivateFieldGet(_this7, _CSSCoverage_instances, \"m\", _CSSCoverage_onExecutionContextsCleared).bind(_this7))], \"f\");\n      yield Promise.all([__classPrivateFieldGet(_this7, _CSSCoverage_client, \"f\").send('DOM.enable'), __classPrivateFieldGet(_this7, _CSSCoverage_client, \"f\").send('CSS.enable'), __classPrivateFieldGet(_this7, _CSSCoverage_client, \"f\").send('CSS.startRuleUsageTracking')]);\n    })();\n  }\n  stop() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      assert(__classPrivateFieldGet(_this8, _CSSCoverage_enabled, \"f\"), 'CSSCoverage is not enabled');\n      __classPrivateFieldSet(_this8, _CSSCoverage_enabled, false, \"f\");\n      const ruleTrackingResponse = yield __classPrivateFieldGet(_this8, _CSSCoverage_client, \"f\").send('CSS.stopRuleUsageTracking');\n      yield Promise.all([__classPrivateFieldGet(_this8, _CSSCoverage_client, \"f\").send('CSS.disable'), __classPrivateFieldGet(_this8, _CSSCoverage_client, \"f\").send('DOM.disable')]);\n      removeEventListeners(__classPrivateFieldGet(_this8, _CSSCoverage_eventListeners, \"f\"));\n      // aggregate by styleSheetId\n      const styleSheetIdToCoverage = new Map();\n      for (const entry of ruleTrackingResponse.ruleUsage) {\n        let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n        if (!ranges) {\n          ranges = [];\n          styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n        }\n        ranges.push({\n          startOffset: entry.startOffset,\n          endOffset: entry.endOffset,\n          count: entry.used ? 1 : 0\n        });\n      }\n      const coverage = [];\n      for (const styleSheetId of __classPrivateFieldGet(_this8, _CSSCoverage_stylesheetURLs, \"f\").keys()) {\n        const url = __classPrivateFieldGet(_this8, _CSSCoverage_stylesheetURLs, \"f\").get(styleSheetId);\n        assert(typeof url !== 'undefined', `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);\n        const text = __classPrivateFieldGet(_this8, _CSSCoverage_stylesheetSources, \"f\").get(styleSheetId);\n        assert(typeof text !== 'undefined', `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);\n        const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n        coverage.push({\n          url,\n          ranges,\n          text\n        });\n      }\n      return coverage;\n    })();\n  }\n}\n_CSSCoverage_client = new WeakMap(), _CSSCoverage_enabled = new WeakMap(), _CSSCoverage_stylesheetURLs = new WeakMap(), _CSSCoverage_stylesheetSources = new WeakMap(), _CSSCoverage_eventListeners = new WeakMap(), _CSSCoverage_resetOnNavigation = new WeakMap(), _CSSCoverage_instances = new WeakSet(), _CSSCoverage_onExecutionContextsCleared = function _CSSCoverage_onExecutionContextsCleared() {\n  if (!__classPrivateFieldGet(this, _CSSCoverage_resetOnNavigation, \"f\")) {\n    return;\n  }\n  __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, \"f\").clear();\n  __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, \"f\").clear();\n}, _CSSCoverage_onStyleSheet = /*#__PURE__*/function () {\n  var _CSSCoverage_onStyleSheet2 = _asyncToGenerator(function* (event) {\n    const header = event.header;\n    // Ignore anonymous scripts\n    if (!header.sourceURL) {\n      return;\n    }\n    try {\n      const response = yield __classPrivateFieldGet(this, _CSSCoverage_client, \"f\").send('CSS.getStyleSheetText', {\n        styleSheetId: header.styleSheetId\n      });\n      __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, \"f\").set(header.styleSheetId, header.sourceURL);\n      __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, \"f\").set(header.styleSheetId, response.text);\n    } catch (error) {\n      // This might happen if the page has already navigated away.\n      debugError(error);\n    }\n  });\n  function _CSSCoverage_onStyleSheet(_x2) {\n    return _CSSCoverage_onStyleSheet2.apply(this, arguments);\n  }\n  return _CSSCoverage_onStyleSheet;\n}();\nfunction convertToDisjointRanges(nestedRanges) {\n  const points = [];\n  for (const range of nestedRanges) {\n    points.push({\n      offset: range.startOffset,\n      type: 0,\n      range\n    });\n    points.push({\n      offset: range.endOffset,\n      type: 1,\n      range\n    });\n  }\n  // Sort points to form a valid parenthesis sequence.\n  points.sort((a, b) => {\n    // Sort with increasing offsets.\n    if (a.offset !== b.offset) {\n      return a.offset - b.offset;\n    }\n    // All \"end\" points should go before \"start\" points.\n    if (a.type !== b.type) {\n      return b.type - a.type;\n    }\n    const aLength = a.range.endOffset - a.range.startOffset;\n    const bLength = b.range.endOffset - b.range.startOffset;\n    // For two \"start\" points, the one with longer range goes first.\n    if (a.type === 0) {\n      return bLength - aLength;\n    }\n    // For two \"end\" points, the one with shorter range goes first.\n    return aLength - bLength;\n  });\n  const hitCountStack = [];\n  const results = [];\n  let lastOffset = 0;\n  // Run scanning line to intersect all ranges.\n  for (const point of points) {\n    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {\n      const lastResult = results[results.length - 1];\n      if (lastResult && lastResult.end === lastOffset) {\n        lastResult.end = point.offset;\n      } else {\n        results.push({\n          start: lastOffset,\n          end: point.offset\n        });\n      }\n    }\n    lastOffset = point.offset;\n    if (point.type === 0) {\n      hitCountStack.push(point.range.count);\n    } else {\n      hitCountStack.pop();\n    }\n  }\n  // Filter out empty ranges.\n  return results.filter(range => {\n    return range.end - range.start > 0;\n  });\n}","map":{"version":3,"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","_Coverage_jsCoverage","_Coverage_cssCoverage","_JSCoverage_instances","_JSCoverage_client","_JSCoverage_enabled","_JSCoverage_scriptURLs","_JSCoverage_scriptSources","_JSCoverage_eventListeners","_JSCoverage_resetOnNavigation","_JSCoverage_reportAnonymousScripts","_JSCoverage_includeRawScriptCoverage","_JSCoverage_onExecutionContextsCleared","_JSCoverage_onScriptParsed","_CSSCoverage_instances","_CSSCoverage_client","_CSSCoverage_enabled","_CSSCoverage_stylesheetURLs","_CSSCoverage_stylesheetSources","_CSSCoverage_eventListeners","_CSSCoverage_resetOnNavigation","_CSSCoverage_onExecutionContextsCleared","_CSSCoverage_onStyleSheet","assert","EVALUATION_SCRIPT_URL","addEventListener","debugError","removeEventListeners","Coverage","constructor","client","JSCoverage","CSSCoverage","startJSCoverage","options","start","stopJSCoverage","stop","startCSSCoverage","stopCSSCoverage","WeakMap","add","Map","resetOnNavigation","reportAnonymousScripts","includeRawScriptCoverage","useBlockCoverage","clear","bind","Promise","all","send","callCount","detailed","skip","result","coverage","profileResponse","entry","url","scriptId","text","undefined","flattenRanges","func","functions","push","ranges","convertToDisjointRanges","rawScriptCoverage","WeakSet","event","response","scriptSource","error","ruleTrackingResponse","styleSheetIdToCoverage","ruleUsage","styleSheetId","startOffset","endOffset","count","used","keys","header","sourceURL","nestedRanges","points","range","offset","type","sort","a","b","aLength","bLength","hitCountStack","results","lastOffset","point","length","lastResult","end","pop","filter"],"sources":["/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/puppeteer-core/lib/esm/puppeteer/common/Coverage.js"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Coverage_jsCoverage, _Coverage_cssCoverage, _JSCoverage_instances, _JSCoverage_client, _JSCoverage_enabled, _JSCoverage_scriptURLs, _JSCoverage_scriptSources, _JSCoverage_eventListeners, _JSCoverage_resetOnNavigation, _JSCoverage_reportAnonymousScripts, _JSCoverage_includeRawScriptCoverage, _JSCoverage_onExecutionContextsCleared, _JSCoverage_onScriptParsed, _CSSCoverage_instances, _CSSCoverage_client, _CSSCoverage_enabled, _CSSCoverage_stylesheetURLs, _CSSCoverage_stylesheetSources, _CSSCoverage_eventListeners, _CSSCoverage_resetOnNavigation, _CSSCoverage_onExecutionContextsCleared, _CSSCoverage_onStyleSheet;\nimport { assert } from '../util/assert.js';\nimport { EVALUATION_SCRIPT_URL } from './ExecutionContext.js';\nimport { addEventListener, debugError } from './util.js';\nimport { removeEventListeners } from './util.js';\n/**\n * The Coverage class provides methods to gather information about parts of\n * JavaScript and CSS that were used by the page.\n *\n * @remarks\n * To output coverage in a form consumable by {@link https://github.com/istanbuljs | Istanbul},\n * see {@link https://github.com/istanbuljs/puppeteer-to-istanbul | puppeteer-to-istanbul}.\n *\n * @example\n * An example of using JavaScript and CSS coverage to get percentage of initially\n * executed code:\n *\n * ```ts\n * // Enable both JavaScript and CSS coverage\n * await Promise.all([\n *   page.coverage.startJSCoverage(),\n *   page.coverage.startCSSCoverage(),\n * ]);\n * // Navigate to page\n * await page.goto('https://example.com');\n * // Disable both JavaScript and CSS coverage\n * const [jsCoverage, cssCoverage] = await Promise.all([\n *   page.coverage.stopJSCoverage(),\n *   page.coverage.stopCSSCoverage(),\n * ]);\n * let totalBytes = 0;\n * let usedBytes = 0;\n * const coverage = [...jsCoverage, ...cssCoverage];\n * for (const entry of coverage) {\n *   totalBytes += entry.text.length;\n *   for (const range of entry.ranges) usedBytes += range.end - range.start - 1;\n * }\n * console.log(`Bytes used: ${(usedBytes / totalBytes) * 100}%`);\n * ```\n *\n * @public\n */\nexport class Coverage {\n    constructor(client) {\n        _Coverage_jsCoverage.set(this, void 0);\n        _Coverage_cssCoverage.set(this, void 0);\n        __classPrivateFieldSet(this, _Coverage_jsCoverage, new JSCoverage(client), \"f\");\n        __classPrivateFieldSet(this, _Coverage_cssCoverage, new CSSCoverage(client), \"f\");\n    }\n    /**\n     * @param options - Set of configurable options for coverage defaults to\n     * `resetOnNavigation : true, reportAnonymousScripts : false,`\n     * `includeRawScriptCoverage : false, useBlockCoverage : true`\n     * @returns Promise that resolves when coverage is started.\n     *\n     * @remarks\n     * Anonymous scripts are ones that don't have an associated url. These are\n     * scripts that are dynamically created on the page using `eval` or\n     * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous\n     * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL\n     * comment is present, in which case that will the be URL).\n     */\n    async startJSCoverage(options = {}) {\n        return await __classPrivateFieldGet(this, _Coverage_jsCoverage, \"f\").start(options);\n    }\n    /**\n     * Promise that resolves to the array of coverage reports for\n     * all scripts.\n     *\n     * @remarks\n     * JavaScript Coverage doesn't include anonymous scripts by default.\n     * However, scripts with sourceURLs are reported.\n     */\n    async stopJSCoverage() {\n        return await __classPrivateFieldGet(this, _Coverage_jsCoverage, \"f\").stop();\n    }\n    /**\n     * @param options - Set of configurable options for coverage, defaults to\n     * `resetOnNavigation : true`\n     * @returns Promise that resolves when coverage is started.\n     */\n    async startCSSCoverage(options = {}) {\n        return await __classPrivateFieldGet(this, _Coverage_cssCoverage, \"f\").start(options);\n    }\n    /**\n     * Promise that resolves to the array of coverage reports\n     * for all stylesheets.\n     *\n     * @remarks\n     * CSS Coverage doesn't include dynamically injected style tags\n     * without sourceURLs.\n     */\n    async stopCSSCoverage() {\n        return await __classPrivateFieldGet(this, _Coverage_cssCoverage, \"f\").stop();\n    }\n}\n_Coverage_jsCoverage = new WeakMap(), _Coverage_cssCoverage = new WeakMap();\n/**\n * @public\n */\nexport class JSCoverage {\n    constructor(client) {\n        _JSCoverage_instances.add(this);\n        _JSCoverage_client.set(this, void 0);\n        _JSCoverage_enabled.set(this, false);\n        _JSCoverage_scriptURLs.set(this, new Map());\n        _JSCoverage_scriptSources.set(this, new Map());\n        _JSCoverage_eventListeners.set(this, []);\n        _JSCoverage_resetOnNavigation.set(this, false);\n        _JSCoverage_reportAnonymousScripts.set(this, false);\n        _JSCoverage_includeRawScriptCoverage.set(this, false);\n        __classPrivateFieldSet(this, _JSCoverage_client, client, \"f\");\n    }\n    async start(options = {}) {\n        assert(!__classPrivateFieldGet(this, _JSCoverage_enabled, \"f\"), 'JSCoverage is already enabled');\n        const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true, } = options;\n        __classPrivateFieldSet(this, _JSCoverage_resetOnNavigation, resetOnNavigation, \"f\");\n        __classPrivateFieldSet(this, _JSCoverage_reportAnonymousScripts, reportAnonymousScripts, \"f\");\n        __classPrivateFieldSet(this, _JSCoverage_includeRawScriptCoverage, includeRawScriptCoverage, \"f\");\n        __classPrivateFieldSet(this, _JSCoverage_enabled, true, \"f\");\n        __classPrivateFieldGet(this, _JSCoverage_scriptURLs, \"f\").clear();\n        __classPrivateFieldGet(this, _JSCoverage_scriptSources, \"f\").clear();\n        __classPrivateFieldSet(this, _JSCoverage_eventListeners, [\n            addEventListener(__classPrivateFieldGet(this, _JSCoverage_client, \"f\"), 'Debugger.scriptParsed', __classPrivateFieldGet(this, _JSCoverage_instances, \"m\", _JSCoverage_onScriptParsed).bind(this)),\n            addEventListener(__classPrivateFieldGet(this, _JSCoverage_client, \"f\"), 'Runtime.executionContextsCleared', __classPrivateFieldGet(this, _JSCoverage_instances, \"m\", _JSCoverage_onExecutionContextsCleared).bind(this)),\n        ], \"f\");\n        await Promise.all([\n            __classPrivateFieldGet(this, _JSCoverage_client, \"f\").send('Profiler.enable'),\n            __classPrivateFieldGet(this, _JSCoverage_client, \"f\").send('Profiler.startPreciseCoverage', {\n                callCount: __classPrivateFieldGet(this, _JSCoverage_includeRawScriptCoverage, \"f\"),\n                detailed: useBlockCoverage,\n            }),\n            __classPrivateFieldGet(this, _JSCoverage_client, \"f\").send('Debugger.enable'),\n            __classPrivateFieldGet(this, _JSCoverage_client, \"f\").send('Debugger.setSkipAllPauses', { skip: true }),\n        ]);\n    }\n    async stop() {\n        assert(__classPrivateFieldGet(this, _JSCoverage_enabled, \"f\"), 'JSCoverage is not enabled');\n        __classPrivateFieldSet(this, _JSCoverage_enabled, false, \"f\");\n        const result = await Promise.all([\n            __classPrivateFieldGet(this, _JSCoverage_client, \"f\").send('Profiler.takePreciseCoverage'),\n            __classPrivateFieldGet(this, _JSCoverage_client, \"f\").send('Profiler.stopPreciseCoverage'),\n            __classPrivateFieldGet(this, _JSCoverage_client, \"f\").send('Profiler.disable'),\n            __classPrivateFieldGet(this, _JSCoverage_client, \"f\").send('Debugger.disable'),\n        ]);\n        removeEventListeners(__classPrivateFieldGet(this, _JSCoverage_eventListeners, \"f\"));\n        const coverage = [];\n        const profileResponse = result[0];\n        for (const entry of profileResponse.result) {\n            let url = __classPrivateFieldGet(this, _JSCoverage_scriptURLs, \"f\").get(entry.scriptId);\n            if (!url && __classPrivateFieldGet(this, _JSCoverage_reportAnonymousScripts, \"f\")) {\n                url = 'debugger://VM' + entry.scriptId;\n            }\n            const text = __classPrivateFieldGet(this, _JSCoverage_scriptSources, \"f\").get(entry.scriptId);\n            if (text === undefined || url === undefined) {\n                continue;\n            }\n            const flattenRanges = [];\n            for (const func of entry.functions) {\n                flattenRanges.push(...func.ranges);\n            }\n            const ranges = convertToDisjointRanges(flattenRanges);\n            if (!__classPrivateFieldGet(this, _JSCoverage_includeRawScriptCoverage, \"f\")) {\n                coverage.push({ url, ranges, text });\n            }\n            else {\n                coverage.push({ url, ranges, text, rawScriptCoverage: entry });\n            }\n        }\n        return coverage;\n    }\n}\n_JSCoverage_client = new WeakMap(), _JSCoverage_enabled = new WeakMap(), _JSCoverage_scriptURLs = new WeakMap(), _JSCoverage_scriptSources = new WeakMap(), _JSCoverage_eventListeners = new WeakMap(), _JSCoverage_resetOnNavigation = new WeakMap(), _JSCoverage_reportAnonymousScripts = new WeakMap(), _JSCoverage_includeRawScriptCoverage = new WeakMap(), _JSCoverage_instances = new WeakSet(), _JSCoverage_onExecutionContextsCleared = function _JSCoverage_onExecutionContextsCleared() {\n    if (!__classPrivateFieldGet(this, _JSCoverage_resetOnNavigation, \"f\")) {\n        return;\n    }\n    __classPrivateFieldGet(this, _JSCoverage_scriptURLs, \"f\").clear();\n    __classPrivateFieldGet(this, _JSCoverage_scriptSources, \"f\").clear();\n}, _JSCoverage_onScriptParsed = async function _JSCoverage_onScriptParsed(event) {\n    // Ignore puppeteer-injected scripts\n    if (event.url === EVALUATION_SCRIPT_URL) {\n        return;\n    }\n    // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.\n    if (!event.url && !__classPrivateFieldGet(this, _JSCoverage_reportAnonymousScripts, \"f\")) {\n        return;\n    }\n    try {\n        const response = await __classPrivateFieldGet(this, _JSCoverage_client, \"f\").send('Debugger.getScriptSource', {\n            scriptId: event.scriptId,\n        });\n        __classPrivateFieldGet(this, _JSCoverage_scriptURLs, \"f\").set(event.scriptId, event.url);\n        __classPrivateFieldGet(this, _JSCoverage_scriptSources, \"f\").set(event.scriptId, response.scriptSource);\n    }\n    catch (error) {\n        // This might happen if the page has already navigated away.\n        debugError(error);\n    }\n};\n/**\n * @public\n */\nexport class CSSCoverage {\n    constructor(client) {\n        _CSSCoverage_instances.add(this);\n        _CSSCoverage_client.set(this, void 0);\n        _CSSCoverage_enabled.set(this, false);\n        _CSSCoverage_stylesheetURLs.set(this, new Map());\n        _CSSCoverage_stylesheetSources.set(this, new Map());\n        _CSSCoverage_eventListeners.set(this, []);\n        _CSSCoverage_resetOnNavigation.set(this, false);\n        __classPrivateFieldSet(this, _CSSCoverage_client, client, \"f\");\n    }\n    async start(options = {}) {\n        assert(!__classPrivateFieldGet(this, _CSSCoverage_enabled, \"f\"), 'CSSCoverage is already enabled');\n        const { resetOnNavigation = true } = options;\n        __classPrivateFieldSet(this, _CSSCoverage_resetOnNavigation, resetOnNavigation, \"f\");\n        __classPrivateFieldSet(this, _CSSCoverage_enabled, true, \"f\");\n        __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, \"f\").clear();\n        __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, \"f\").clear();\n        __classPrivateFieldSet(this, _CSSCoverage_eventListeners, [\n            addEventListener(__classPrivateFieldGet(this, _CSSCoverage_client, \"f\"), 'CSS.styleSheetAdded', __classPrivateFieldGet(this, _CSSCoverage_instances, \"m\", _CSSCoverage_onStyleSheet).bind(this)),\n            addEventListener(__classPrivateFieldGet(this, _CSSCoverage_client, \"f\"), 'Runtime.executionContextsCleared', __classPrivateFieldGet(this, _CSSCoverage_instances, \"m\", _CSSCoverage_onExecutionContextsCleared).bind(this)),\n        ], \"f\");\n        await Promise.all([\n            __classPrivateFieldGet(this, _CSSCoverage_client, \"f\").send('DOM.enable'),\n            __classPrivateFieldGet(this, _CSSCoverage_client, \"f\").send('CSS.enable'),\n            __classPrivateFieldGet(this, _CSSCoverage_client, \"f\").send('CSS.startRuleUsageTracking'),\n        ]);\n    }\n    async stop() {\n        assert(__classPrivateFieldGet(this, _CSSCoverage_enabled, \"f\"), 'CSSCoverage is not enabled');\n        __classPrivateFieldSet(this, _CSSCoverage_enabled, false, \"f\");\n        const ruleTrackingResponse = await __classPrivateFieldGet(this, _CSSCoverage_client, \"f\").send('CSS.stopRuleUsageTracking');\n        await Promise.all([\n            __classPrivateFieldGet(this, _CSSCoverage_client, \"f\").send('CSS.disable'),\n            __classPrivateFieldGet(this, _CSSCoverage_client, \"f\").send('DOM.disable'),\n        ]);\n        removeEventListeners(__classPrivateFieldGet(this, _CSSCoverage_eventListeners, \"f\"));\n        // aggregate by styleSheetId\n        const styleSheetIdToCoverage = new Map();\n        for (const entry of ruleTrackingResponse.ruleUsage) {\n            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);\n            if (!ranges) {\n                ranges = [];\n                styleSheetIdToCoverage.set(entry.styleSheetId, ranges);\n            }\n            ranges.push({\n                startOffset: entry.startOffset,\n                endOffset: entry.endOffset,\n                count: entry.used ? 1 : 0,\n            });\n        }\n        const coverage = [];\n        for (const styleSheetId of __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, \"f\").keys()) {\n            const url = __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, \"f\").get(styleSheetId);\n            assert(typeof url !== 'undefined', `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);\n            const text = __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, \"f\").get(styleSheetId);\n            assert(typeof text !== 'undefined', `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);\n            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);\n            coverage.push({ url, ranges, text });\n        }\n        return coverage;\n    }\n}\n_CSSCoverage_client = new WeakMap(), _CSSCoverage_enabled = new WeakMap(), _CSSCoverage_stylesheetURLs = new WeakMap(), _CSSCoverage_stylesheetSources = new WeakMap(), _CSSCoverage_eventListeners = new WeakMap(), _CSSCoverage_resetOnNavigation = new WeakMap(), _CSSCoverage_instances = new WeakSet(), _CSSCoverage_onExecutionContextsCleared = function _CSSCoverage_onExecutionContextsCleared() {\n    if (!__classPrivateFieldGet(this, _CSSCoverage_resetOnNavigation, \"f\")) {\n        return;\n    }\n    __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, \"f\").clear();\n    __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, \"f\").clear();\n}, _CSSCoverage_onStyleSheet = async function _CSSCoverage_onStyleSheet(event) {\n    const header = event.header;\n    // Ignore anonymous scripts\n    if (!header.sourceURL) {\n        return;\n    }\n    try {\n        const response = await __classPrivateFieldGet(this, _CSSCoverage_client, \"f\").send('CSS.getStyleSheetText', {\n            styleSheetId: header.styleSheetId,\n        });\n        __classPrivateFieldGet(this, _CSSCoverage_stylesheetURLs, \"f\").set(header.styleSheetId, header.sourceURL);\n        __classPrivateFieldGet(this, _CSSCoverage_stylesheetSources, \"f\").set(header.styleSheetId, response.text);\n    }\n    catch (error) {\n        // This might happen if the page has already navigated away.\n        debugError(error);\n    }\n};\nfunction convertToDisjointRanges(nestedRanges) {\n    const points = [];\n    for (const range of nestedRanges) {\n        points.push({ offset: range.startOffset, type: 0, range });\n        points.push({ offset: range.endOffset, type: 1, range });\n    }\n    // Sort points to form a valid parenthesis sequence.\n    points.sort((a, b) => {\n        // Sort with increasing offsets.\n        if (a.offset !== b.offset) {\n            return a.offset - b.offset;\n        }\n        // All \"end\" points should go before \"start\" points.\n        if (a.type !== b.type) {\n            return b.type - a.type;\n        }\n        const aLength = a.range.endOffset - a.range.startOffset;\n        const bLength = b.range.endOffset - b.range.startOffset;\n        // For two \"start\" points, the one with longer range goes first.\n        if (a.type === 0) {\n            return bLength - aLength;\n        }\n        // For two \"end\" points, the one with shorter range goes first.\n        return aLength - bLength;\n    });\n    const hitCountStack = [];\n    const results = [];\n    let lastOffset = 0;\n    // Run scanning line to intersect all ranges.\n    for (const point of points) {\n        if (hitCountStack.length &&\n            lastOffset < point.offset &&\n            hitCountStack[hitCountStack.length - 1] > 0) {\n            const lastResult = results[results.length - 1];\n            if (lastResult && lastResult.end === lastOffset) {\n                lastResult.end = point.offset;\n            }\n            else {\n                results.push({ start: lastOffset, end: point.offset });\n            }\n        }\n        lastOffset = point.offset;\n        if (point.type === 0) {\n            hitCountStack.push(point.range.count);\n        }\n        else {\n            hitCountStack.pop();\n        }\n    }\n    // Filter out empty ranges.\n    return results.filter(range => {\n        return range.end - range.start > 0;\n    });\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,sBAAsB,GAAI,IAAI,IAAI,IAAI,CAACA,sBAAsB,IAAK,UAAUC,QAAQ,EAAEC,KAAK,EAAEC,KAAK,EAAEC,IAAI,EAAEC,CAAC,EAAE;EAC7G,IAAID,IAAI,KAAK,GAAG,EAAE,MAAM,IAAIE,SAAS,CAAC,gCAAgC,CAAC;EACvE,IAAIF,IAAI,KAAK,GAAG,IAAI,CAACC,CAAC,EAAE,MAAM,IAAIC,SAAS,CAAC,+CAA+C,CAAC;EAC5F,IAAI,OAAOJ,KAAK,KAAK,UAAU,GAAGD,QAAQ,KAAKC,KAAK,IAAI,CAACG,CAAC,GAAG,CAACH,KAAK,CAACK,GAAG,CAACN,QAAQ,CAAC,EAAE,MAAM,IAAIK,SAAS,CAAC,yEAAyE,CAAC;EACjL,OAAQF,IAAI,KAAK,GAAG,GAAGC,CAAC,CAACG,IAAI,CAACP,QAAQ,EAAEE,KAAK,CAAC,GAAGE,CAAC,GAAGA,CAAC,CAACF,KAAK,GAAGA,KAAK,GAAGD,KAAK,CAACO,GAAG,CAACR,QAAQ,EAAEE,KAAK,CAAC,EAAGA,KAAK;AAC7G,CAAC;AACD,IAAIO,sBAAsB,GAAI,IAAI,IAAI,IAAI,CAACA,sBAAsB,IAAK,UAAUT,QAAQ,EAAEC,KAAK,EAAEE,IAAI,EAAEC,CAAC,EAAE;EACtG,IAAID,IAAI,KAAK,GAAG,IAAI,CAACC,CAAC,EAAE,MAAM,IAAIC,SAAS,CAAC,+CAA+C,CAAC;EAC5F,IAAI,OAAOJ,KAAK,KAAK,UAAU,GAAGD,QAAQ,KAAKC,KAAK,IAAI,CAACG,CAAC,GAAG,CAACH,KAAK,CAACK,GAAG,CAACN,QAAQ,CAAC,EAAE,MAAM,IAAIK,SAAS,CAAC,0EAA0E,CAAC;EAClL,OAAOF,IAAI,KAAK,GAAG,GAAGC,CAAC,GAAGD,IAAI,KAAK,GAAG,GAAGC,CAAC,CAACG,IAAI,CAACP,QAAQ,CAAC,GAAGI,CAAC,GAAGA,CAAC,CAACF,KAAK,GAAGD,KAAK,CAACS,GAAG,CAACV,QAAQ,CAAC;AACjG,CAAC;AACD,IAAIW,oBAAoB,EAAEC,qBAAqB,EAAEC,qBAAqB,EAAEC,kBAAkB,EAAEC,mBAAmB,EAAEC,sBAAsB,EAAEC,yBAAyB,EAAEC,0BAA0B,EAAEC,6BAA6B,EAAEC,kCAAkC,EAAEC,oCAAoC,EAAEC,sCAAsC,EAAEC,0BAA0B,EAAEC,sBAAsB,EAAEC,mBAAmB,EAAEC,oBAAoB,EAAEC,2BAA2B,EAAEC,8BAA8B,EAAEC,2BAA2B,EAAEC,8BAA8B,EAAEC,uCAAuC,EAAEC,yBAAyB;AAC5mB,SAASC,MAAM,QAAQ,mBAAmB;AAC1C,SAASC,qBAAqB,QAAQ,uBAAuB;AAC7D,SAASC,gBAAgB,EAAEC,UAAU,QAAQ,WAAW;AACxD,SAASC,oBAAoB,QAAQ,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,QAAQ,CAAC;EAClBC,WAAW,CAACC,MAAM,EAAE;IAChB7B,oBAAoB,CAACH,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACtCI,qBAAqB,CAACJ,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACvCT,sBAAsB,CAAC,IAAI,EAAEY,oBAAoB,EAAE,IAAI8B,UAAU,CAACD,MAAM,CAAC,EAAE,GAAG,CAAC;IAC/EzC,sBAAsB,CAAC,IAAI,EAAEa,qBAAqB,EAAE,IAAI8B,WAAW,CAACF,MAAM,CAAC,EAAE,GAAG,CAAC;EACrF;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUG,eAAe,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IAAA;IAAA;MAChC,aAAanC,sBAAsB,CAAC,KAAI,EAAEE,oBAAoB,EAAE,GAAG,CAAC,CAACkC,KAAK,CAACD,OAAO,CAAC;IAAC;EACxF;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACUE,cAAc,GAAG;IAAA;IAAA;MACnB,aAAarC,sBAAsB,CAAC,MAAI,EAAEE,oBAAoB,EAAE,GAAG,CAAC,CAACoC,IAAI,EAAE;IAAC;EAChF;EACA;AACJ;AACA;AACA;AACA;EACUC,gBAAgB,CAACJ,OAAO,GAAG,CAAC,CAAC,EAAE;IAAA;IAAA;MACjC,aAAanC,sBAAsB,CAAC,MAAI,EAAEG,qBAAqB,EAAE,GAAG,CAAC,CAACiC,KAAK,CAACD,OAAO,CAAC;IAAC;EACzF;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACUK,eAAe,GAAG;IAAA;IAAA;MACpB,aAAaxC,sBAAsB,CAAC,MAAI,EAAEG,qBAAqB,EAAE,GAAG,CAAC,CAACmC,IAAI,EAAE;IAAC;EACjF;AACJ;AACApC,oBAAoB,GAAG,IAAIuC,OAAO,EAAE,EAAEtC,qBAAqB,GAAG,IAAIsC,OAAO,EAAE;AAC3E;AACA;AACA;AACA,OAAO,MAAMT,UAAU,CAAC;EACpBF,WAAW,CAACC,MAAM,EAAE;IAChB3B,qBAAqB,CAACsC,GAAG,CAAC,IAAI,CAAC;IAC/BrC,kBAAkB,CAACN,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACpCO,mBAAmB,CAACP,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;IACpCQ,sBAAsB,CAACR,GAAG,CAAC,IAAI,EAAE,IAAI4C,GAAG,EAAE,CAAC;IAC3CnC,yBAAyB,CAACT,GAAG,CAAC,IAAI,EAAE,IAAI4C,GAAG,EAAE,CAAC;IAC9ClC,0BAA0B,CAACV,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC;IACxCW,6BAA6B,CAACX,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;IAC9CY,kCAAkC,CAACZ,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;IACnDa,oCAAoC,CAACb,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;IACrDT,sBAAsB,CAAC,IAAI,EAAEe,kBAAkB,EAAE0B,MAAM,EAAE,GAAG,CAAC;EACjE;EACMK,KAAK,CAACD,OAAO,GAAG,CAAC,CAAC,EAAE;IAAA;IAAA;MACtBX,MAAM,CAAC,CAACxB,sBAAsB,CAAC,MAAI,EAAEM,mBAAmB,EAAE,GAAG,CAAC,EAAE,+BAA+B,CAAC;MAChG,MAAM;QAAEsC,iBAAiB,GAAG,IAAI;QAAEC,sBAAsB,GAAG,KAAK;QAAEC,wBAAwB,GAAG,KAAK;QAAEC,gBAAgB,GAAG;MAAM,CAAC,GAAGZ,OAAO;MACxI7C,sBAAsB,CAAC,MAAI,EAAEoB,6BAA6B,EAAEkC,iBAAiB,EAAE,GAAG,CAAC;MACnFtD,sBAAsB,CAAC,MAAI,EAAEqB,kCAAkC,EAAEkC,sBAAsB,EAAE,GAAG,CAAC;MAC7FvD,sBAAsB,CAAC,MAAI,EAAEsB,oCAAoC,EAAEkC,wBAAwB,EAAE,GAAG,CAAC;MACjGxD,sBAAsB,CAAC,MAAI,EAAEgB,mBAAmB,EAAE,IAAI,EAAE,GAAG,CAAC;MAC5DN,sBAAsB,CAAC,MAAI,EAAEO,sBAAsB,EAAE,GAAG,CAAC,CAACyC,KAAK,EAAE;MACjEhD,sBAAsB,CAAC,MAAI,EAAEQ,yBAAyB,EAAE,GAAG,CAAC,CAACwC,KAAK,EAAE;MACpE1D,sBAAsB,CAAC,MAAI,EAAEmB,0BAA0B,EAAE,CACrDiB,gBAAgB,CAAC1B,sBAAsB,CAAC,MAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,EAAE,uBAAuB,EAAEL,sBAAsB,CAAC,MAAI,EAAEI,qBAAqB,EAAE,GAAG,EAAEU,0BAA0B,CAAC,CAACmC,IAAI,CAAC,MAAI,CAAC,CAAC,EACjMvB,gBAAgB,CAAC1B,sBAAsB,CAAC,MAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,EAAE,kCAAkC,EAAEL,sBAAsB,CAAC,MAAI,EAAEI,qBAAqB,EAAE,GAAG,EAAES,sCAAsC,CAAC,CAACoC,IAAI,CAAC,MAAI,CAAC,CAAC,CAC3N,EAAE,GAAG,CAAC;MACP,MAAMC,OAAO,CAACC,GAAG,CAAC,CACdnD,sBAAsB,CAAC,MAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,CAAC+C,IAAI,CAAC,iBAAiB,CAAC,EAC7EpD,sBAAsB,CAAC,MAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,CAAC+C,IAAI,CAAC,+BAA+B,EAAE;QACxFC,SAAS,EAAErD,sBAAsB,CAAC,MAAI,EAAEY,oCAAoC,EAAE,GAAG,CAAC;QAClF0C,QAAQ,EAAEP;MACd,CAAC,CAAC,EACF/C,sBAAsB,CAAC,MAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,CAAC+C,IAAI,CAAC,iBAAiB,CAAC,EAC7EpD,sBAAsB,CAAC,MAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,CAAC+C,IAAI,CAAC,2BAA2B,EAAE;QAAEG,IAAI,EAAE;MAAK,CAAC,CAAC,CAC1G,CAAC;IAAC;EACP;EACMjB,IAAI,GAAG;IAAA;IAAA;MACTd,MAAM,CAACxB,sBAAsB,CAAC,MAAI,EAAEM,mBAAmB,EAAE,GAAG,CAAC,EAAE,2BAA2B,CAAC;MAC3FhB,sBAAsB,CAAC,MAAI,EAAEgB,mBAAmB,EAAE,KAAK,EAAE,GAAG,CAAC;MAC7D,MAAMkD,MAAM,SAASN,OAAO,CAACC,GAAG,CAAC,CAC7BnD,sBAAsB,CAAC,MAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,CAAC+C,IAAI,CAAC,8BAA8B,CAAC,EAC1FpD,sBAAsB,CAAC,MAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,CAAC+C,IAAI,CAAC,8BAA8B,CAAC,EAC1FpD,sBAAsB,CAAC,MAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,CAAC+C,IAAI,CAAC,kBAAkB,CAAC,EAC9EpD,sBAAsB,CAAC,MAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,CAAC+C,IAAI,CAAC,kBAAkB,CAAC,CACjF,CAAC;MACFxB,oBAAoB,CAAC5B,sBAAsB,CAAC,MAAI,EAAES,0BAA0B,EAAE,GAAG,CAAC,CAAC;MACnF,MAAMgD,QAAQ,GAAG,EAAE;MACnB,MAAMC,eAAe,GAAGF,MAAM,CAAC,CAAC,CAAC;MACjC,KAAK,MAAMG,KAAK,IAAID,eAAe,CAACF,MAAM,EAAE;QACxC,IAAII,GAAG,GAAG5D,sBAAsB,CAAC,MAAI,EAAEO,sBAAsB,EAAE,GAAG,CAAC,CAACN,GAAG,CAAC0D,KAAK,CAACE,QAAQ,CAAC;QACvF,IAAI,CAACD,GAAG,IAAI5D,sBAAsB,CAAC,MAAI,EAAEW,kCAAkC,EAAE,GAAG,CAAC,EAAE;UAC/EiD,GAAG,GAAG,eAAe,GAAGD,KAAK,CAACE,QAAQ;QAC1C;QACA,MAAMC,IAAI,GAAG9D,sBAAsB,CAAC,MAAI,EAAEQ,yBAAyB,EAAE,GAAG,CAAC,CAACP,GAAG,CAAC0D,KAAK,CAACE,QAAQ,CAAC;QAC7F,IAAIC,IAAI,KAAKC,SAAS,IAAIH,GAAG,KAAKG,SAAS,EAAE;UACzC;QACJ;QACA,MAAMC,aAAa,GAAG,EAAE;QACxB,KAAK,MAAMC,IAAI,IAAIN,KAAK,CAACO,SAAS,EAAE;UAChCF,aAAa,CAACG,IAAI,CAAC,GAAGF,IAAI,CAACG,MAAM,CAAC;QACtC;QACA,MAAMA,MAAM,GAAGC,uBAAuB,CAACL,aAAa,CAAC;QACrD,IAAI,CAAChE,sBAAsB,CAAC,MAAI,EAAEY,oCAAoC,EAAE,GAAG,CAAC,EAAE;UAC1E6C,QAAQ,CAACU,IAAI,CAAC;YAAEP,GAAG;YAAEQ,MAAM;YAAEN;UAAK,CAAC,CAAC;QACxC,CAAC,MACI;UACDL,QAAQ,CAACU,IAAI,CAAC;YAAEP,GAAG;YAAEQ,MAAM;YAAEN,IAAI;YAAEQ,iBAAiB,EAAEX;UAAM,CAAC,CAAC;QAClE;MACJ;MACA,OAAOF,QAAQ;IAAC;EACpB;AACJ;AACApD,kBAAkB,GAAG,IAAIoC,OAAO,EAAE,EAAEnC,mBAAmB,GAAG,IAAImC,OAAO,EAAE,EAAElC,sBAAsB,GAAG,IAAIkC,OAAO,EAAE,EAAEjC,yBAAyB,GAAG,IAAIiC,OAAO,EAAE,EAAEhC,0BAA0B,GAAG,IAAIgC,OAAO,EAAE,EAAE/B,6BAA6B,GAAG,IAAI+B,OAAO,EAAE,EAAE9B,kCAAkC,GAAG,IAAI8B,OAAO,EAAE,EAAE7B,oCAAoC,GAAG,IAAI6B,OAAO,EAAE,EAAErC,qBAAqB,GAAG,IAAImE,OAAO,EAAE,EAAE1D,sCAAsC,GAAG,SAASA,sCAAsC,GAAG;EAC/d,IAAI,CAACb,sBAAsB,CAAC,IAAI,EAAEU,6BAA6B,EAAE,GAAG,CAAC,EAAE;IACnE;EACJ;EACAV,sBAAsB,CAAC,IAAI,EAAEO,sBAAsB,EAAE,GAAG,CAAC,CAACyC,KAAK,EAAE;EACjEhD,sBAAsB,CAAC,IAAI,EAAEQ,yBAAyB,EAAE,GAAG,CAAC,CAACwC,KAAK,EAAE;AACxE,CAAC,EAAElC,0BAA0B;EAAA,oDAAG,WAA0C0D,KAAK,EAAE;IAC7E;IACA,IAAIA,KAAK,CAACZ,GAAG,KAAKnC,qBAAqB,EAAE;MACrC;IACJ;IACA;IACA,IAAI,CAAC+C,KAAK,CAACZ,GAAG,IAAI,CAAC5D,sBAAsB,CAAC,IAAI,EAAEW,kCAAkC,EAAE,GAAG,CAAC,EAAE;MACtF;IACJ;IACA,IAAI;MACA,MAAM8D,QAAQ,SAASzE,sBAAsB,CAAC,IAAI,EAAEK,kBAAkB,EAAE,GAAG,CAAC,CAAC+C,IAAI,CAAC,0BAA0B,EAAE;QAC1GS,QAAQ,EAAEW,KAAK,CAACX;MACpB,CAAC,CAAC;MACF7D,sBAAsB,CAAC,IAAI,EAAEO,sBAAsB,EAAE,GAAG,CAAC,CAACR,GAAG,CAACyE,KAAK,CAACX,QAAQ,EAAEW,KAAK,CAACZ,GAAG,CAAC;MACxF5D,sBAAsB,CAAC,IAAI,EAAEQ,yBAAyB,EAAE,GAAG,CAAC,CAACT,GAAG,CAACyE,KAAK,CAACX,QAAQ,EAAEY,QAAQ,CAACC,YAAY,CAAC;IAC3G,CAAC,CACD,OAAOC,KAAK,EAAE;MACV;MACAhD,UAAU,CAACgD,KAAK,CAAC;IACrB;EACJ,CAAC;EAAA,SApB8C7D,0BAA0B;IAAA;EAAA;EAAA,OAA1BA,0BAA0B;AAAA,GAoBxE;AACD;AACA;AACA;AACA,OAAO,MAAMmB,WAAW,CAAC;EACrBH,WAAW,CAACC,MAAM,EAAE;IAChBhB,sBAAsB,CAAC2B,GAAG,CAAC,IAAI,CAAC;IAChC1B,mBAAmB,CAACjB,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;IACrCkB,oBAAoB,CAAClB,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;IACrCmB,2BAA2B,CAACnB,GAAG,CAAC,IAAI,EAAE,IAAI4C,GAAG,EAAE,CAAC;IAChDxB,8BAA8B,CAACpB,GAAG,CAAC,IAAI,EAAE,IAAI4C,GAAG,EAAE,CAAC;IACnDvB,2BAA2B,CAACrB,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC;IACzCsB,8BAA8B,CAACtB,GAAG,CAAC,IAAI,EAAE,KAAK,CAAC;IAC/CT,sBAAsB,CAAC,IAAI,EAAE0B,mBAAmB,EAAEe,MAAM,EAAE,GAAG,CAAC;EAClE;EACMK,KAAK,CAACD,OAAO,GAAG,CAAC,CAAC,EAAE;IAAA;IAAA;MACtBX,MAAM,CAAC,CAACxB,sBAAsB,CAAC,MAAI,EAAEiB,oBAAoB,EAAE,GAAG,CAAC,EAAE,gCAAgC,CAAC;MAClG,MAAM;QAAE2B,iBAAiB,GAAG;MAAK,CAAC,GAAGT,OAAO;MAC5C7C,sBAAsB,CAAC,MAAI,EAAE+B,8BAA8B,EAAEuB,iBAAiB,EAAE,GAAG,CAAC;MACpFtD,sBAAsB,CAAC,MAAI,EAAE2B,oBAAoB,EAAE,IAAI,EAAE,GAAG,CAAC;MAC7DjB,sBAAsB,CAAC,MAAI,EAAEkB,2BAA2B,EAAE,GAAG,CAAC,CAAC8B,KAAK,EAAE;MACtEhD,sBAAsB,CAAC,MAAI,EAAEmB,8BAA8B,EAAE,GAAG,CAAC,CAAC6B,KAAK,EAAE;MACzE1D,sBAAsB,CAAC,MAAI,EAAE8B,2BAA2B,EAAE,CACtDM,gBAAgB,CAAC1B,sBAAsB,CAAC,MAAI,EAAEgB,mBAAmB,EAAE,GAAG,CAAC,EAAE,qBAAqB,EAAEhB,sBAAsB,CAAC,MAAI,EAAEe,sBAAsB,EAAE,GAAG,EAAEQ,yBAAyB,CAAC,CAAC0B,IAAI,CAAC,MAAI,CAAC,CAAC,EAChMvB,gBAAgB,CAAC1B,sBAAsB,CAAC,MAAI,EAAEgB,mBAAmB,EAAE,GAAG,CAAC,EAAE,kCAAkC,EAAEhB,sBAAsB,CAAC,MAAI,EAAEe,sBAAsB,EAAE,GAAG,EAAEO,uCAAuC,CAAC,CAAC2B,IAAI,CAAC,MAAI,CAAC,CAAC,CAC9N,EAAE,GAAG,CAAC;MACP,MAAMC,OAAO,CAACC,GAAG,CAAC,CACdnD,sBAAsB,CAAC,MAAI,EAAEgB,mBAAmB,EAAE,GAAG,CAAC,CAACoC,IAAI,CAAC,YAAY,CAAC,EACzEpD,sBAAsB,CAAC,MAAI,EAAEgB,mBAAmB,EAAE,GAAG,CAAC,CAACoC,IAAI,CAAC,YAAY,CAAC,EACzEpD,sBAAsB,CAAC,MAAI,EAAEgB,mBAAmB,EAAE,GAAG,CAAC,CAACoC,IAAI,CAAC,4BAA4B,CAAC,CAC5F,CAAC;IAAC;EACP;EACMd,IAAI,GAAG;IAAA;IAAA;MACTd,MAAM,CAACxB,sBAAsB,CAAC,MAAI,EAAEiB,oBAAoB,EAAE,GAAG,CAAC,EAAE,4BAA4B,CAAC;MAC7F3B,sBAAsB,CAAC,MAAI,EAAE2B,oBAAoB,EAAE,KAAK,EAAE,GAAG,CAAC;MAC9D,MAAM2D,oBAAoB,SAAS5E,sBAAsB,CAAC,MAAI,EAAEgB,mBAAmB,EAAE,GAAG,CAAC,CAACoC,IAAI,CAAC,2BAA2B,CAAC;MAC3H,MAAMF,OAAO,CAACC,GAAG,CAAC,CACdnD,sBAAsB,CAAC,MAAI,EAAEgB,mBAAmB,EAAE,GAAG,CAAC,CAACoC,IAAI,CAAC,aAAa,CAAC,EAC1EpD,sBAAsB,CAAC,MAAI,EAAEgB,mBAAmB,EAAE,GAAG,CAAC,CAACoC,IAAI,CAAC,aAAa,CAAC,CAC7E,CAAC;MACFxB,oBAAoB,CAAC5B,sBAAsB,CAAC,MAAI,EAAEoB,2BAA2B,EAAE,GAAG,CAAC,CAAC;MACpF;MACA,MAAMyD,sBAAsB,GAAG,IAAIlC,GAAG,EAAE;MACxC,KAAK,MAAMgB,KAAK,IAAIiB,oBAAoB,CAACE,SAAS,EAAE;QAChD,IAAIV,MAAM,GAAGS,sBAAsB,CAAC5E,GAAG,CAAC0D,KAAK,CAACoB,YAAY,CAAC;QAC3D,IAAI,CAACX,MAAM,EAAE;UACTA,MAAM,GAAG,EAAE;UACXS,sBAAsB,CAAC9E,GAAG,CAAC4D,KAAK,CAACoB,YAAY,EAAEX,MAAM,CAAC;QAC1D;QACAA,MAAM,CAACD,IAAI,CAAC;UACRa,WAAW,EAAErB,KAAK,CAACqB,WAAW;UAC9BC,SAAS,EAAEtB,KAAK,CAACsB,SAAS;UAC1BC,KAAK,EAAEvB,KAAK,CAACwB,IAAI,GAAG,CAAC,GAAG;QAC5B,CAAC,CAAC;MACN;MACA,MAAM1B,QAAQ,GAAG,EAAE;MACnB,KAAK,MAAMsB,YAAY,IAAI/E,sBAAsB,CAAC,MAAI,EAAEkB,2BAA2B,EAAE,GAAG,CAAC,CAACkE,IAAI,EAAE,EAAE;QAC9F,MAAMxB,GAAG,GAAG5D,sBAAsB,CAAC,MAAI,EAAEkB,2BAA2B,EAAE,GAAG,CAAC,CAACjB,GAAG,CAAC8E,YAAY,CAAC;QAC5FvD,MAAM,CAAC,OAAOoC,GAAG,KAAK,WAAW,EAAG,6CAA4CmB,YAAa,GAAE,CAAC;QAChG,MAAMjB,IAAI,GAAG9D,sBAAsB,CAAC,MAAI,EAAEmB,8BAA8B,EAAE,GAAG,CAAC,CAAClB,GAAG,CAAC8E,YAAY,CAAC;QAChGvD,MAAM,CAAC,OAAOsC,IAAI,KAAK,WAAW,EAAG,8CAA6CiB,YAAa,GAAE,CAAC;QAClG,MAAMX,MAAM,GAAGC,uBAAuB,CAACQ,sBAAsB,CAAC5E,GAAG,CAAC8E,YAAY,CAAC,IAAI,EAAE,CAAC;QACtFtB,QAAQ,CAACU,IAAI,CAAC;UAAEP,GAAG;UAAEQ,MAAM;UAAEN;QAAK,CAAC,CAAC;MACxC;MACA,OAAOL,QAAQ;IAAC;EACpB;AACJ;AACAzC,mBAAmB,GAAG,IAAIyB,OAAO,EAAE,EAAExB,oBAAoB,GAAG,IAAIwB,OAAO,EAAE,EAAEvB,2BAA2B,GAAG,IAAIuB,OAAO,EAAE,EAAEtB,8BAA8B,GAAG,IAAIsB,OAAO,EAAE,EAAErB,2BAA2B,GAAG,IAAIqB,OAAO,EAAE,EAAEpB,8BAA8B,GAAG,IAAIoB,OAAO,EAAE,EAAE1B,sBAAsB,GAAG,IAAIwD,OAAO,EAAE,EAAEjD,uCAAuC,GAAG,SAASA,uCAAuC,GAAG;EACtY,IAAI,CAACtB,sBAAsB,CAAC,IAAI,EAAEqB,8BAA8B,EAAE,GAAG,CAAC,EAAE;IACpE;EACJ;EACArB,sBAAsB,CAAC,IAAI,EAAEkB,2BAA2B,EAAE,GAAG,CAAC,CAAC8B,KAAK,EAAE;EACtEhD,sBAAsB,CAAC,IAAI,EAAEmB,8BAA8B,EAAE,GAAG,CAAC,CAAC6B,KAAK,EAAE;AAC7E,CAAC,EAAEzB,yBAAyB;EAAA,mDAAG,WAAyCiD,KAAK,EAAE;IAC3E,MAAMa,MAAM,GAAGb,KAAK,CAACa,MAAM;IAC3B;IACA,IAAI,CAACA,MAAM,CAACC,SAAS,EAAE;MACnB;IACJ;IACA,IAAI;MACA,MAAMb,QAAQ,SAASzE,sBAAsB,CAAC,IAAI,EAAEgB,mBAAmB,EAAE,GAAG,CAAC,CAACoC,IAAI,CAAC,uBAAuB,EAAE;QACxG2B,YAAY,EAAEM,MAAM,CAACN;MACzB,CAAC,CAAC;MACF/E,sBAAsB,CAAC,IAAI,EAAEkB,2BAA2B,EAAE,GAAG,CAAC,CAACnB,GAAG,CAACsF,MAAM,CAACN,YAAY,EAAEM,MAAM,CAACC,SAAS,CAAC;MACzGtF,sBAAsB,CAAC,IAAI,EAAEmB,8BAA8B,EAAE,GAAG,CAAC,CAACpB,GAAG,CAACsF,MAAM,CAACN,YAAY,EAAEN,QAAQ,CAACX,IAAI,CAAC;IAC7G,CAAC,CACD,OAAOa,KAAK,EAAE;MACV;MACAhD,UAAU,CAACgD,KAAK,CAAC;IACrB;EACJ,CAAC;EAAA,SAjB6CpD,yBAAyB;IAAA;EAAA;EAAA,OAAzBA,yBAAyB;AAAA,GAiBtE;AACD,SAAS8C,uBAAuB,CAACkB,YAAY,EAAE;EAC3C,MAAMC,MAAM,GAAG,EAAE;EACjB,KAAK,MAAMC,KAAK,IAAIF,YAAY,EAAE;IAC9BC,MAAM,CAACrB,IAAI,CAAC;MAAEuB,MAAM,EAAED,KAAK,CAACT,WAAW;MAAEW,IAAI,EAAE,CAAC;MAAEF;IAAM,CAAC,CAAC;IAC1DD,MAAM,CAACrB,IAAI,CAAC;MAAEuB,MAAM,EAAED,KAAK,CAACR,SAAS;MAAEU,IAAI,EAAE,CAAC;MAAEF;IAAM,CAAC,CAAC;EAC5D;EACA;EACAD,MAAM,CAACI,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;IAClB;IACA,IAAID,CAAC,CAACH,MAAM,KAAKI,CAAC,CAACJ,MAAM,EAAE;MACvB,OAAOG,CAAC,CAACH,MAAM,GAAGI,CAAC,CAACJ,MAAM;IAC9B;IACA;IACA,IAAIG,CAAC,CAACF,IAAI,KAAKG,CAAC,CAACH,IAAI,EAAE;MACnB,OAAOG,CAAC,CAACH,IAAI,GAAGE,CAAC,CAACF,IAAI;IAC1B;IACA,MAAMI,OAAO,GAAGF,CAAC,CAACJ,KAAK,CAACR,SAAS,GAAGY,CAAC,CAACJ,KAAK,CAACT,WAAW;IACvD,MAAMgB,OAAO,GAAGF,CAAC,CAACL,KAAK,CAACR,SAAS,GAAGa,CAAC,CAACL,KAAK,CAACT,WAAW;IACvD;IACA,IAAIa,CAAC,CAACF,IAAI,KAAK,CAAC,EAAE;MACd,OAAOK,OAAO,GAAGD,OAAO;IAC5B;IACA;IACA,OAAOA,OAAO,GAAGC,OAAO;EAC5B,CAAC,CAAC;EACF,MAAMC,aAAa,GAAG,EAAE;EACxB,MAAMC,OAAO,GAAG,EAAE;EAClB,IAAIC,UAAU,GAAG,CAAC;EAClB;EACA,KAAK,MAAMC,KAAK,IAAIZ,MAAM,EAAE;IACxB,IAAIS,aAAa,CAACI,MAAM,IACpBF,UAAU,GAAGC,KAAK,CAACV,MAAM,IACzBO,aAAa,CAACA,aAAa,CAACI,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE;MAC7C,MAAMC,UAAU,GAAGJ,OAAO,CAACA,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC;MAC9C,IAAIC,UAAU,IAAIA,UAAU,CAACC,GAAG,KAAKJ,UAAU,EAAE;QAC7CG,UAAU,CAACC,GAAG,GAAGH,KAAK,CAACV,MAAM;MACjC,CAAC,MACI;QACDQ,OAAO,CAAC/B,IAAI,CAAC;UAAE/B,KAAK,EAAE+D,UAAU;UAAEI,GAAG,EAAEH,KAAK,CAACV;QAAO,CAAC,CAAC;MAC1D;IACJ;IACAS,UAAU,GAAGC,KAAK,CAACV,MAAM;IACzB,IAAIU,KAAK,CAACT,IAAI,KAAK,CAAC,EAAE;MAClBM,aAAa,CAAC9B,IAAI,CAACiC,KAAK,CAACX,KAAK,CAACP,KAAK,CAAC;IACzC,CAAC,MACI;MACDe,aAAa,CAACO,GAAG,EAAE;IACvB;EACJ;EACA;EACA,OAAON,OAAO,CAACO,MAAM,CAAChB,KAAK,IAAI;IAC3B,OAAOA,KAAK,CAACc,GAAG,GAAGd,KAAK,CAACrD,KAAK,GAAG,CAAC;EACtC,CAAC,CAAC;AACN"},"metadata":{},"sourceType":"module","externalDependencies":[]}