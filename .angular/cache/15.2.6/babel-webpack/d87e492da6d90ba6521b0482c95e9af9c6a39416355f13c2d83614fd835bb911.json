{"ast":null,"code":"import _asyncToGenerator from \"/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BrowserFetcher_instances, _BrowserFetcher_product, _BrowserFetcher_downloadPath, _BrowserFetcher_downloadHost, _BrowserFetcher_platform, _BrowserFetcher_getFolderPath;\nimport { exec as execChildProcess } from 'child_process';\nimport { createReadStream, createWriteStream, existsSync, readdirSync } from 'fs';\nimport { chmod, mkdir, readdir, unlink } from 'fs/promises';\nimport http from 'http';\nimport https from 'https';\nimport os from 'os';\nimport path from 'path';\nimport URL from 'url';\nimport { promisify, format } from 'util';\nimport extractZip from 'extract-zip';\nimport createHttpsProxyAgent from 'https-proxy-agent';\nimport { getProxyForUrl } from 'proxy-from-env';\nimport tar from 'tar-fs';\nimport bzip from 'unbzip2-stream';\nimport { debug } from '../common/Debug.js';\nimport { assert } from '../util/assert.js';\nimport { rm } from '../util/fs.js';\nconst debugFetcher = debug('puppeteer:fetcher');\nconst downloadURLs = {\n  chrome: {\n    linux: '%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip',\n    mac: '%s/chromium-browser-snapshots/Mac/%d/%s.zip',\n    mac_arm: '%s/chromium-browser-snapshots/Mac_Arm/%d/%s.zip',\n    win32: '%s/chromium-browser-snapshots/Win/%d/%s.zip',\n    win64: '%s/chromium-browser-snapshots/Win_x64/%d/%s.zip'\n  },\n  firefox: {\n    linux: '%s/firefox-%s.en-US.%s-x86_64.tar.bz2',\n    mac: '%s/firefox-%s.en-US.%s.dmg',\n    win32: '%s/firefox-%s.en-US.%s.zip',\n    win64: '%s/firefox-%s.en-US.%s.zip'\n  }\n};\nconst browserConfig = {\n  chrome: {\n    host: 'https://storage.googleapis.com'\n  },\n  firefox: {\n    host: 'https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central'\n  }\n};\nconst exec = promisify(execChildProcess);\nfunction archiveName(product, platform, revision) {\n  switch (product) {\n    case 'chrome':\n      switch (platform) {\n        case 'linux':\n          return 'chrome-linux';\n        case 'mac_arm':\n        case 'mac':\n          return 'chrome-mac';\n        case 'win32':\n        case 'win64':\n          // Windows archive name changed at r591479.\n          return parseInt(revision, 10) > 591479 ? 'chrome-win' : 'chrome-win32';\n      }\n    case 'firefox':\n      return platform;\n  }\n}\nfunction downloadURL(product, platform, host, revision) {\n  const url = format(downloadURLs[product][platform], host, revision, archiveName(product, platform, revision));\n  return url;\n}\nfunction handleArm64() {\n  let exists = existsSync('/usr/bin/chromium-browser');\n  if (exists) {\n    return;\n  }\n  exists = existsSync('/usr/bin/chromium');\n  if (exists) {\n    return;\n  }\n  console.error('The chromium binary is not available for arm64.' + '\\nIf you are on Ubuntu, you can install with: ' + '\\n\\n sudo apt install chromium\\n' + '\\n\\n sudo apt install chromium-browser\\n');\n  throw new Error();\n}\n/**\n * BrowserFetcher can download and manage different versions of Chromium and\n * Firefox.\n *\n * @remarks\n * BrowserFetcher operates on revision strings that specify a precise version of\n * Chromium, e.g. `\"533271\"`. Revision strings can be obtained from\n * {@link http://omahaproxy.appspot.com/ | omahaproxy.appspot.com}. For Firefox,\n * BrowserFetcher downloads Firefox Nightly and operates on version numbers such\n * as `\"75\"`.\n *\n * @remarks\n * The default constructed fetcher will always be for Chromium unless otherwise\n * specified.\n *\n * @remarks\n * BrowserFetcher is not designed to work concurrently with other instances of\n * BrowserFetcher that share the same downloads directory.\n *\n * @example\n * An example of using BrowserFetcher to download a specific version of Chromium\n * and running Puppeteer against it:\n *\n * ```ts\n * const browserFetcher = new BrowserFetcher({path: 'path/to/download/folder'});\n * const revisionInfo = await browserFetcher.download('533271');\n * const browser = await puppeteer.launch({\n *   executablePath: revisionInfo.executablePath,\n * });\n * ```\n *\n * @public\n */\nexport class BrowserFetcher {\n  /**\n   * Constructs a browser fetcher for the given options.\n   */\n  constructor(options) {\n    var _a, _b;\n    _BrowserFetcher_instances.add(this);\n    _BrowserFetcher_product.set(this, void 0);\n    _BrowserFetcher_downloadPath.set(this, void 0);\n    _BrowserFetcher_downloadHost.set(this, void 0);\n    _BrowserFetcher_platform.set(this, void 0);\n    __classPrivateFieldSet(this, _BrowserFetcher_product, (_a = options.product) !== null && _a !== void 0 ? _a : 'chrome', \"f\");\n    __classPrivateFieldSet(this, _BrowserFetcher_downloadPath, options.path, \"f\");\n    __classPrivateFieldSet(this, _BrowserFetcher_downloadHost, (_b = options.host) !== null && _b !== void 0 ? _b : browserConfig[__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\")].host, \"f\");\n    if (options.platform) {\n      __classPrivateFieldSet(this, _BrowserFetcher_platform, options.platform, \"f\");\n    } else {\n      const platform = os.platform();\n      switch (platform) {\n        case 'darwin':\n          switch (__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\")) {\n            case 'chrome':\n              __classPrivateFieldSet(this, _BrowserFetcher_platform, os.arch() === 'arm64' && options.useMacOSARMBinary ? 'mac_arm' : 'mac', \"f\");\n              break;\n            case 'firefox':\n              __classPrivateFieldSet(this, _BrowserFetcher_platform, 'mac', \"f\");\n              break;\n          }\n          break;\n        case 'linux':\n          __classPrivateFieldSet(this, _BrowserFetcher_platform, 'linux', \"f\");\n          break;\n        case 'win32':\n          __classPrivateFieldSet(this, _BrowserFetcher_platform, os.arch() === 'x64' ||\n          // Windows 11 for ARM supports x64 emulation\n          os.arch() === 'arm64' && isWindows11(os.release()) ? 'win64' : 'win32', \"f\");\n          return;\n        default:\n          assert(false, 'Unsupported platform: ' + platform);\n      }\n    }\n    assert(downloadURLs[__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\")][__classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\")], 'Unsupported platform: ' + __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"));\n  }\n  /**\n   * Returns the current `Platform`, which is one of `mac`, `linux`,\n   * `win32` or `win64`.\n   */\n  platform() {\n    return __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\");\n  }\n  /**\n   * Returns the current `Product`, which is one of `chrome` or\n   * `firefox`.\n   */\n  product() {\n    return __classPrivateFieldGet(this, _BrowserFetcher_product, \"f\");\n  }\n  /**\n   * The download host being used.\n   */\n  host() {\n    return __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, \"f\");\n  }\n  /**\n   * Initiates a HEAD request to check if the revision is available.\n   * @remarks\n   * This method is affected by the current `product`.\n   * @param revision - The revision to check availability for.\n   * @returns A promise that resolves to `true` if the revision could be downloaded\n   * from the host.\n   */\n  canDownload(revision) {\n    const url = downloadURL(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, \"f\"), revision);\n    return new Promise(resolve => {\n      const request = httpRequest(url, 'HEAD', response => {\n        resolve(response.statusCode === 200);\n      }, false);\n      request.on('error', error => {\n        console.error(error);\n        resolve(false);\n      });\n    });\n  }\n  /**\n   * Initiates a GET request to download the revision from the host.\n   * @remarks\n   * This method is affected by the current `product`.\n   * @param revision - The revision to download.\n   * @param progressCallback - A function that will be called with two arguments:\n   * How many bytes have been downloaded and the total number of bytes of the download.\n   * @returns A promise with revision information when the revision is downloaded\n   * and extracted.\n   */\n  download(revision, progressCallback = () => {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const url = downloadURL(__classPrivateFieldGet(_this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(_this, _BrowserFetcher_platform, \"f\"), __classPrivateFieldGet(_this, _BrowserFetcher_downloadHost, \"f\"), revision);\n      const fileName = url.split('/').pop();\n      assert(fileName, `A malformed download URL was found: ${url}.`);\n      const archivePath = path.join(__classPrivateFieldGet(_this, _BrowserFetcher_downloadPath, \"f\"), fileName);\n      const outputPath = __classPrivateFieldGet(_this, _BrowserFetcher_instances, \"m\", _BrowserFetcher_getFolderPath).call(_this, revision);\n      if (existsSync(outputPath)) {\n        return _this.revisionInfo(revision);\n      }\n      if (!existsSync(__classPrivateFieldGet(_this, _BrowserFetcher_downloadPath, \"f\"))) {\n        yield mkdir(__classPrivateFieldGet(_this, _BrowserFetcher_downloadPath, \"f\"), {\n          recursive: true\n        });\n      }\n      // Use system Chromium builds on Linux ARM devices\n      if (os.platform() === 'linux' && os.arch() === 'arm64') {\n        handleArm64();\n        return;\n      }\n      try {\n        yield _downloadFile(url, archivePath, progressCallback);\n        yield install(archivePath, outputPath);\n      } finally {\n        if (existsSync(archivePath)) {\n          yield unlink(archivePath);\n        }\n      }\n      const revisionInfo = _this.revisionInfo(revision);\n      if (revisionInfo) {\n        yield chmod(revisionInfo.executablePath, 0o755);\n      }\n      return revisionInfo;\n    })();\n  }\n  /**\n   * @remarks\n   * This method is affected by the current `product`.\n   * @returns A list of all revision strings (for the current `product`)\n   * available locally on disk.\n   */\n  localRevisions() {\n    if (!existsSync(__classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\"))) {\n      return [];\n    }\n    const fileNames = readdirSync(__classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\"));\n    return fileNames.map(fileName => {\n      return parseFolderPath(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), fileName);\n    }).filter(entry => {\n      var _a;\n      return (_a = entry && entry.platform === __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\")) !== null && _a !== void 0 ? _a : false;\n    }).map(entry => {\n      return entry.revision;\n    });\n  }\n  /**\n   * @remarks\n   * This method is affected by the current `product`.\n   * @param revision - A revision to remove for the current `product`.\n   * @returns A promise that resolves when the revision has been removed or\n   * throws if the revision has not been downloaded.\n   */\n  remove(revision) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const folderPath = __classPrivateFieldGet(_this2, _BrowserFetcher_instances, \"m\", _BrowserFetcher_getFolderPath).call(_this2, revision);\n      assert(existsSync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);\n      yield rm(folderPath);\n    })();\n  }\n  /**\n   * @param revision - The revision to get info for.\n   * @returns The revision info for the given revision.\n   */\n  revisionInfo(revision) {\n    const folderPath = __classPrivateFieldGet(this, _BrowserFetcher_instances, \"m\", _BrowserFetcher_getFolderPath).call(this, revision);\n    let executablePath = '';\n    switch (__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\")) {\n      case 'chrome':\n        switch (__classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\")) {\n          case 'mac':\n          case 'mac_arm':\n            executablePath = path.join(folderPath, archiveName(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), revision), 'Chromium.app', 'Contents', 'MacOS', 'Chromium');\n            break;\n          case 'linux':\n            executablePath = path.join(folderPath, archiveName(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), revision), 'chrome');\n            break;\n          case 'win32':\n          case 'win64':\n            executablePath = path.join(folderPath, archiveName(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), revision), 'chrome.exe');\n            break;\n        }\n        break;\n      case 'firefox':\n        switch (__classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\")) {\n          case 'mac':\n          case 'mac_arm':\n            executablePath = path.join(folderPath, 'Firefox Nightly.app', 'Contents', 'MacOS', 'firefox');\n            break;\n          case 'linux':\n            executablePath = path.join(folderPath, 'firefox', 'firefox');\n            break;\n          case 'win32':\n          case 'win64':\n            executablePath = path.join(folderPath, 'firefox', 'firefox.exe');\n            break;\n        }\n    }\n    const url = downloadURL(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, \"f\"), revision);\n    const local = existsSync(folderPath);\n    debugFetcher({\n      revision,\n      executablePath,\n      folderPath,\n      local,\n      url,\n      product: __classPrivateFieldGet(this, _BrowserFetcher_product, \"f\")\n    });\n    return {\n      revision,\n      executablePath,\n      folderPath,\n      local,\n      url,\n      product: __classPrivateFieldGet(this, _BrowserFetcher_product, \"f\")\n    };\n  }\n  /**\n   * @internal\n   */\n  getDownloadPath() {\n    return __classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\");\n  }\n}\n_BrowserFetcher_product = new WeakMap(), _BrowserFetcher_downloadPath = new WeakMap(), _BrowserFetcher_downloadHost = new WeakMap(), _BrowserFetcher_platform = new WeakMap(), _BrowserFetcher_instances = new WeakSet(), _BrowserFetcher_getFolderPath = function _BrowserFetcher_getFolderPath(revision) {\n  return path.resolve(__classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\"), `${__classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\")}-${revision}`);\n};\nfunction parseFolderPath(product, folderPath) {\n  const name = path.basename(folderPath);\n  const splits = name.split('-');\n  if (splits.length !== 2) {\n    return;\n  }\n  const [platform, revision] = splits;\n  if (!revision || !platform || !(platform in downloadURLs[product])) {\n    return;\n  }\n  return {\n    product,\n    platform,\n    revision\n  };\n}\n/**\n * Windows 11 is identified by 10.0.22000 or greater\n * @internal\n */\nfunction isWindows11(version) {\n  const parts = version.split('.');\n  if (parts.length > 2) {\n    const major = parseInt(parts[0], 10);\n    const minor = parseInt(parts[1], 10);\n    const patch = parseInt(parts[2], 10);\n    return major > 10 || major === 10 && minor > 0 || major === 10 && minor === 0 && patch >= 22000;\n  }\n  return false;\n}\n/**\n * @internal\n */\nfunction _downloadFile(url, destinationPath, progressCallback) {\n  debugFetcher(`Downloading binary from ${url}`);\n  let fulfill;\n  let reject;\n  const promise = new Promise((x, y) => {\n    fulfill = x;\n    reject = y;\n  });\n  let downloadedBytes = 0;\n  let totalBytes = 0;\n  const request = httpRequest(url, 'GET', response => {\n    if (response.statusCode !== 200) {\n      const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);\n      // consume response data to free up memory\n      response.resume();\n      reject(error);\n      return;\n    }\n    const file = createWriteStream(destinationPath);\n    file.on('finish', () => {\n      return fulfill();\n    });\n    file.on('error', error => {\n      return reject(error);\n    });\n    response.pipe(file);\n    totalBytes = parseInt(response.headers['content-length'], 10);\n    if (progressCallback) {\n      response.on('data', onData);\n    }\n  });\n  request.on('error', error => {\n    return reject(error);\n  });\n  return promise;\n  function onData(chunk) {\n    downloadedBytes += chunk.length;\n    progressCallback(downloadedBytes, totalBytes);\n  }\n}\nfunction install(_x, _x2) {\n  return _install.apply(this, arguments);\n}\n/**\n * @internal\n */\nfunction _install() {\n  _install = _asyncToGenerator(function* (archivePath, folderPath) {\n    debugFetcher(`Installing ${archivePath} to ${folderPath}`);\n    if (archivePath.endsWith('.zip')) {\n      yield extractZip(archivePath, {\n        dir: folderPath\n      });\n    } else if (archivePath.endsWith('.tar.bz2')) {\n      yield extractTar(archivePath, folderPath);\n    } else if (archivePath.endsWith('.dmg')) {\n      yield mkdir(folderPath);\n      yield installDMG(archivePath, folderPath);\n    } else {\n      throw new Error(`Unsupported archive format: ${archivePath}`);\n    }\n  });\n  return _install.apply(this, arguments);\n}\nfunction extractTar(tarPath, folderPath) {\n  return new Promise((fulfill, reject) => {\n    const tarStream = tar.extract(folderPath);\n    tarStream.on('error', reject);\n    tarStream.on('finish', fulfill);\n    const readStream = createReadStream(tarPath);\n    readStream.pipe(bzip()).pipe(tarStream);\n  });\n}\n/**\n * @internal\n */\nfunction installDMG(_x3, _x4) {\n  return _installDMG.apply(this, arguments);\n}\nfunction _installDMG() {\n  _installDMG = _asyncToGenerator(function* (dmgPath, folderPath) {\n    const {\n      stdout\n    } = yield exec(`hdiutil attach -nobrowse -noautoopen \"${dmgPath}\"`);\n    const volumes = stdout.match(/\\/Volumes\\/(.*)/m);\n    if (!volumes) {\n      throw new Error(`Could not find volume path in ${stdout}`);\n    }\n    const mountPath = volumes[0];\n    try {\n      const fileNames = yield readdir(mountPath);\n      const appName = fileNames.find(item => {\n        return typeof item === 'string' && item.endsWith('.app');\n      });\n      if (!appName) {\n        throw new Error(`Cannot find app in ${mountPath}`);\n      }\n      const mountedPath = path.join(mountPath, appName);\n      debugFetcher(`Copying ${mountedPath} to ${folderPath}`);\n      yield exec(`cp -R \"${mountedPath}\" \"${folderPath}\"`);\n    } finally {\n      debugFetcher(`Unmounting ${mountPath}`);\n      yield exec(`hdiutil detach \"${mountPath}\" -quiet`);\n    }\n  });\n  return _installDMG.apply(this, arguments);\n}\nfunction httpRequest(url, method, response, keepAlive = true) {\n  const urlParsed = URL.parse(url);\n  let options = {\n    ...urlParsed,\n    method,\n    headers: keepAlive ? {\n      Connection: 'keep-alive'\n    } : undefined\n  };\n  const proxyURL = getProxyForUrl(url);\n  if (proxyURL) {\n    if (url.startsWith('http:')) {\n      const proxy = URL.parse(proxyURL);\n      options = {\n        path: options.href,\n        host: proxy.hostname,\n        port: proxy.port\n      };\n    } else {\n      const parsedProxyURL = URL.parse(proxyURL);\n      const proxyOptions = {\n        ...parsedProxyURL,\n        secureProxy: parsedProxyURL.protocol === 'https:'\n      };\n      options.agent = createHttpsProxyAgent(proxyOptions);\n      options.rejectUnauthorized = false;\n    }\n  }\n  const requestCallback = res => {\n    if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      httpRequest(res.headers.location, method, response);\n    } else {\n      response(res);\n    }\n  };\n  const request = options.protocol === 'https:' ? https.request(options, requestCallback) : http.request(options, requestCallback);\n  request.end();\n  return request;\n}","map":{"version":3,"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","_BrowserFetcher_instances","_BrowserFetcher_product","_BrowserFetcher_downloadPath","_BrowserFetcher_downloadHost","_BrowserFetcher_platform","_BrowserFetcher_getFolderPath","exec","execChildProcess","createReadStream","createWriteStream","existsSync","readdirSync","chmod","mkdir","readdir","unlink","http","https","os","path","URL","promisify","format","extractZip","createHttpsProxyAgent","getProxyForUrl","tar","bzip","debug","assert","rm","debugFetcher","downloadURLs","chrome","linux","mac","mac_arm","win32","win64","firefox","browserConfig","host","archiveName","product","platform","revision","parseInt","downloadURL","url","handleArm64","exists","console","error","Error","BrowserFetcher","constructor","options","_a","_b","add","arch","useMacOSARMBinary","isWindows11","release","canDownload","Promise","resolve","request","httpRequest","response","statusCode","on","download","progressCallback","fileName","split","pop","archivePath","join","outputPath","revisionInfo","recursive","_downloadFile","install","executablePath","localRevisions","fileNames","map","parseFolderPath","filter","entry","remove","folderPath","local","getDownloadPath","WeakMap","WeakSet","name","basename","splits","length","version","parts","major","minor","patch","destinationPath","fulfill","reject","promise","x","y","downloadedBytes","totalBytes","resume","file","pipe","headers","onData","chunk","endsWith","dir","extractTar","installDMG","tarPath","tarStream","extract","readStream","dmgPath","stdout","volumes","match","mountPath","appName","find","item","mountedPath","method","keepAlive","urlParsed","parse","Connection","undefined","proxyURL","startsWith","proxy","href","hostname","port","parsedProxyURL","proxyOptions","secureProxy","protocol","agent","rejectUnauthorized","requestCallback","res","location","end"],"sources":["/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/puppeteer-core/lib/esm/puppeteer/node/BrowserFetcher.js"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _BrowserFetcher_instances, _BrowserFetcher_product, _BrowserFetcher_downloadPath, _BrowserFetcher_downloadHost, _BrowserFetcher_platform, _BrowserFetcher_getFolderPath;\nimport { exec as execChildProcess } from 'child_process';\nimport { createReadStream, createWriteStream, existsSync, readdirSync } from 'fs';\nimport { chmod, mkdir, readdir, unlink } from 'fs/promises';\nimport http from 'http';\nimport https from 'https';\nimport os from 'os';\nimport path from 'path';\nimport URL from 'url';\nimport { promisify, format } from 'util';\nimport extractZip from 'extract-zip';\nimport createHttpsProxyAgent from 'https-proxy-agent';\nimport { getProxyForUrl } from 'proxy-from-env';\nimport tar from 'tar-fs';\nimport bzip from 'unbzip2-stream';\nimport { debug } from '../common/Debug.js';\nimport { assert } from '../util/assert.js';\nimport { rm } from '../util/fs.js';\nconst debugFetcher = debug('puppeteer:fetcher');\nconst downloadURLs = {\n    chrome: {\n        linux: '%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip',\n        mac: '%s/chromium-browser-snapshots/Mac/%d/%s.zip',\n        mac_arm: '%s/chromium-browser-snapshots/Mac_Arm/%d/%s.zip',\n        win32: '%s/chromium-browser-snapshots/Win/%d/%s.zip',\n        win64: '%s/chromium-browser-snapshots/Win_x64/%d/%s.zip',\n    },\n    firefox: {\n        linux: '%s/firefox-%s.en-US.%s-x86_64.tar.bz2',\n        mac: '%s/firefox-%s.en-US.%s.dmg',\n        win32: '%s/firefox-%s.en-US.%s.zip',\n        win64: '%s/firefox-%s.en-US.%s.zip',\n    },\n};\nconst browserConfig = {\n    chrome: {\n        host: 'https://storage.googleapis.com',\n    },\n    firefox: {\n        host: 'https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central',\n    },\n};\nconst exec = promisify(execChildProcess);\nfunction archiveName(product, platform, revision) {\n    switch (product) {\n        case 'chrome':\n            switch (platform) {\n                case 'linux':\n                    return 'chrome-linux';\n                case 'mac_arm':\n                case 'mac':\n                    return 'chrome-mac';\n                case 'win32':\n                case 'win64':\n                    // Windows archive name changed at r591479.\n                    return parseInt(revision, 10) > 591479\n                        ? 'chrome-win'\n                        : 'chrome-win32';\n            }\n        case 'firefox':\n            return platform;\n    }\n}\nfunction downloadURL(product, platform, host, revision) {\n    const url = format(downloadURLs[product][platform], host, revision, archiveName(product, platform, revision));\n    return url;\n}\nfunction handleArm64() {\n    let exists = existsSync('/usr/bin/chromium-browser');\n    if (exists) {\n        return;\n    }\n    exists = existsSync('/usr/bin/chromium');\n    if (exists) {\n        return;\n    }\n    console.error('The chromium binary is not available for arm64.' +\n        '\\nIf you are on Ubuntu, you can install with: ' +\n        '\\n\\n sudo apt install chromium\\n' +\n        '\\n\\n sudo apt install chromium-browser\\n');\n    throw new Error();\n}\n/**\n * BrowserFetcher can download and manage different versions of Chromium and\n * Firefox.\n *\n * @remarks\n * BrowserFetcher operates on revision strings that specify a precise version of\n * Chromium, e.g. `\"533271\"`. Revision strings can be obtained from\n * {@link http://omahaproxy.appspot.com/ | omahaproxy.appspot.com}. For Firefox,\n * BrowserFetcher downloads Firefox Nightly and operates on version numbers such\n * as `\"75\"`.\n *\n * @remarks\n * The default constructed fetcher will always be for Chromium unless otherwise\n * specified.\n *\n * @remarks\n * BrowserFetcher is not designed to work concurrently with other instances of\n * BrowserFetcher that share the same downloads directory.\n *\n * @example\n * An example of using BrowserFetcher to download a specific version of Chromium\n * and running Puppeteer against it:\n *\n * ```ts\n * const browserFetcher = new BrowserFetcher({path: 'path/to/download/folder'});\n * const revisionInfo = await browserFetcher.download('533271');\n * const browser = await puppeteer.launch({\n *   executablePath: revisionInfo.executablePath,\n * });\n * ```\n *\n * @public\n */\nexport class BrowserFetcher {\n    /**\n     * Constructs a browser fetcher for the given options.\n     */\n    constructor(options) {\n        var _a, _b;\n        _BrowserFetcher_instances.add(this);\n        _BrowserFetcher_product.set(this, void 0);\n        _BrowserFetcher_downloadPath.set(this, void 0);\n        _BrowserFetcher_downloadHost.set(this, void 0);\n        _BrowserFetcher_platform.set(this, void 0);\n        __classPrivateFieldSet(this, _BrowserFetcher_product, (_a = options.product) !== null && _a !== void 0 ? _a : 'chrome', \"f\");\n        __classPrivateFieldSet(this, _BrowserFetcher_downloadPath, options.path, \"f\");\n        __classPrivateFieldSet(this, _BrowserFetcher_downloadHost, (_b = options.host) !== null && _b !== void 0 ? _b : browserConfig[__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\")].host, \"f\");\n        if (options.platform) {\n            __classPrivateFieldSet(this, _BrowserFetcher_platform, options.platform, \"f\");\n        }\n        else {\n            const platform = os.platform();\n            switch (platform) {\n                case 'darwin':\n                    switch (__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\")) {\n                        case 'chrome':\n                            __classPrivateFieldSet(this, _BrowserFetcher_platform, os.arch() === 'arm64' && options.useMacOSARMBinary\n                                ? 'mac_arm'\n                                : 'mac', \"f\");\n                            break;\n                        case 'firefox':\n                            __classPrivateFieldSet(this, _BrowserFetcher_platform, 'mac', \"f\");\n                            break;\n                    }\n                    break;\n                case 'linux':\n                    __classPrivateFieldSet(this, _BrowserFetcher_platform, 'linux', \"f\");\n                    break;\n                case 'win32':\n                    __classPrivateFieldSet(this, _BrowserFetcher_platform, os.arch() === 'x64' ||\n                        // Windows 11 for ARM supports x64 emulation\n                        (os.arch() === 'arm64' && isWindows11(os.release()))\n                        ? 'win64'\n                        : 'win32', \"f\");\n                    return;\n                default:\n                    assert(false, 'Unsupported platform: ' + platform);\n            }\n        }\n        assert(downloadURLs[__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\")][__classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\")], 'Unsupported platform: ' + __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"));\n    }\n    /**\n     * Returns the current `Platform`, which is one of `mac`, `linux`,\n     * `win32` or `win64`.\n     */\n    platform() {\n        return __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\");\n    }\n    /**\n     * Returns the current `Product`, which is one of `chrome` or\n     * `firefox`.\n     */\n    product() {\n        return __classPrivateFieldGet(this, _BrowserFetcher_product, \"f\");\n    }\n    /**\n     * The download host being used.\n     */\n    host() {\n        return __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, \"f\");\n    }\n    /**\n     * Initiates a HEAD request to check if the revision is available.\n     * @remarks\n     * This method is affected by the current `product`.\n     * @param revision - The revision to check availability for.\n     * @returns A promise that resolves to `true` if the revision could be downloaded\n     * from the host.\n     */\n    canDownload(revision) {\n        const url = downloadURL(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, \"f\"), revision);\n        return new Promise(resolve => {\n            const request = httpRequest(url, 'HEAD', response => {\n                resolve(response.statusCode === 200);\n            }, false);\n            request.on('error', error => {\n                console.error(error);\n                resolve(false);\n            });\n        });\n    }\n    /**\n     * Initiates a GET request to download the revision from the host.\n     * @remarks\n     * This method is affected by the current `product`.\n     * @param revision - The revision to download.\n     * @param progressCallback - A function that will be called with two arguments:\n     * How many bytes have been downloaded and the total number of bytes of the download.\n     * @returns A promise with revision information when the revision is downloaded\n     * and extracted.\n     */\n    async download(revision, progressCallback = () => { }) {\n        const url = downloadURL(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, \"f\"), revision);\n        const fileName = url.split('/').pop();\n        assert(fileName, `A malformed download URL was found: ${url}.`);\n        const archivePath = path.join(__classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\"), fileName);\n        const outputPath = __classPrivateFieldGet(this, _BrowserFetcher_instances, \"m\", _BrowserFetcher_getFolderPath).call(this, revision);\n        if (existsSync(outputPath)) {\n            return this.revisionInfo(revision);\n        }\n        if (!existsSync(__classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\"))) {\n            await mkdir(__classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\"), { recursive: true });\n        }\n        // Use system Chromium builds on Linux ARM devices\n        if (os.platform() === 'linux' && os.arch() === 'arm64') {\n            handleArm64();\n            return;\n        }\n        try {\n            await _downloadFile(url, archivePath, progressCallback);\n            await install(archivePath, outputPath);\n        }\n        finally {\n            if (existsSync(archivePath)) {\n                await unlink(archivePath);\n            }\n        }\n        const revisionInfo = this.revisionInfo(revision);\n        if (revisionInfo) {\n            await chmod(revisionInfo.executablePath, 0o755);\n        }\n        return revisionInfo;\n    }\n    /**\n     * @remarks\n     * This method is affected by the current `product`.\n     * @returns A list of all revision strings (for the current `product`)\n     * available locally on disk.\n     */\n    localRevisions() {\n        if (!existsSync(__classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\"))) {\n            return [];\n        }\n        const fileNames = readdirSync(__classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\"));\n        return fileNames\n            .map(fileName => {\n            return parseFolderPath(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), fileName);\n        })\n            .filter((entry) => {\n            var _a;\n            return (_a = (entry && entry.platform === __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"))) !== null && _a !== void 0 ? _a : false;\n        })\n            .map(entry => {\n            return entry.revision;\n        });\n    }\n    /**\n     * @remarks\n     * This method is affected by the current `product`.\n     * @param revision - A revision to remove for the current `product`.\n     * @returns A promise that resolves when the revision has been removed or\n     * throws if the revision has not been downloaded.\n     */\n    async remove(revision) {\n        const folderPath = __classPrivateFieldGet(this, _BrowserFetcher_instances, \"m\", _BrowserFetcher_getFolderPath).call(this, revision);\n        assert(existsSync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);\n        await rm(folderPath);\n    }\n    /**\n     * @param revision - The revision to get info for.\n     * @returns The revision info for the given revision.\n     */\n    revisionInfo(revision) {\n        const folderPath = __classPrivateFieldGet(this, _BrowserFetcher_instances, \"m\", _BrowserFetcher_getFolderPath).call(this, revision);\n        let executablePath = '';\n        switch (__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\")) {\n            case 'chrome':\n                switch (__classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\")) {\n                    case 'mac':\n                    case 'mac_arm':\n                        executablePath = path.join(folderPath, archiveName(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), revision), 'Chromium.app', 'Contents', 'MacOS', 'Chromium');\n                        break;\n                    case 'linux':\n                        executablePath = path.join(folderPath, archiveName(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), revision), 'chrome');\n                        break;\n                    case 'win32':\n                    case 'win64':\n                        executablePath = path.join(folderPath, archiveName(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), revision), 'chrome.exe');\n                        break;\n                }\n                break;\n            case 'firefox':\n                switch (__classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\")) {\n                    case 'mac':\n                    case 'mac_arm':\n                        executablePath = path.join(folderPath, 'Firefox Nightly.app', 'Contents', 'MacOS', 'firefox');\n                        break;\n                    case 'linux':\n                        executablePath = path.join(folderPath, 'firefox', 'firefox');\n                        break;\n                    case 'win32':\n                    case 'win64':\n                        executablePath = path.join(folderPath, 'firefox', 'firefox.exe');\n                        break;\n                }\n        }\n        const url = downloadURL(__classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\"), __classPrivateFieldGet(this, _BrowserFetcher_downloadHost, \"f\"), revision);\n        const local = existsSync(folderPath);\n        debugFetcher({\n            revision,\n            executablePath,\n            folderPath,\n            local,\n            url,\n            product: __classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"),\n        });\n        return {\n            revision,\n            executablePath,\n            folderPath,\n            local,\n            url,\n            product: __classPrivateFieldGet(this, _BrowserFetcher_product, \"f\"),\n        };\n    }\n    /**\n     * @internal\n     */\n    getDownloadPath() {\n        return __classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\");\n    }\n}\n_BrowserFetcher_product = new WeakMap(), _BrowserFetcher_downloadPath = new WeakMap(), _BrowserFetcher_downloadHost = new WeakMap(), _BrowserFetcher_platform = new WeakMap(), _BrowserFetcher_instances = new WeakSet(), _BrowserFetcher_getFolderPath = function _BrowserFetcher_getFolderPath(revision) {\n    return path.resolve(__classPrivateFieldGet(this, _BrowserFetcher_downloadPath, \"f\"), `${__classPrivateFieldGet(this, _BrowserFetcher_platform, \"f\")}-${revision}`);\n};\nfunction parseFolderPath(product, folderPath) {\n    const name = path.basename(folderPath);\n    const splits = name.split('-');\n    if (splits.length !== 2) {\n        return;\n    }\n    const [platform, revision] = splits;\n    if (!revision || !platform || !(platform in downloadURLs[product])) {\n        return;\n    }\n    return { product, platform, revision };\n}\n/**\n * Windows 11 is identified by 10.0.22000 or greater\n * @internal\n */\nfunction isWindows11(version) {\n    const parts = version.split('.');\n    if (parts.length > 2) {\n        const major = parseInt(parts[0], 10);\n        const minor = parseInt(parts[1], 10);\n        const patch = parseInt(parts[2], 10);\n        return (major > 10 ||\n            (major === 10 && minor > 0) ||\n            (major === 10 && minor === 0 && patch >= 22000));\n    }\n    return false;\n}\n/**\n * @internal\n */\nfunction _downloadFile(url, destinationPath, progressCallback) {\n    debugFetcher(`Downloading binary from ${url}`);\n    let fulfill;\n    let reject;\n    const promise = new Promise((x, y) => {\n        fulfill = x;\n        reject = y;\n    });\n    let downloadedBytes = 0;\n    let totalBytes = 0;\n    const request = httpRequest(url, 'GET', response => {\n        if (response.statusCode !== 200) {\n            const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);\n            // consume response data to free up memory\n            response.resume();\n            reject(error);\n            return;\n        }\n        const file = createWriteStream(destinationPath);\n        file.on('finish', () => {\n            return fulfill();\n        });\n        file.on('error', error => {\n            return reject(error);\n        });\n        response.pipe(file);\n        totalBytes = parseInt(response.headers['content-length'], 10);\n        if (progressCallback) {\n            response.on('data', onData);\n        }\n    });\n    request.on('error', error => {\n        return reject(error);\n    });\n    return promise;\n    function onData(chunk) {\n        downloadedBytes += chunk.length;\n        progressCallback(downloadedBytes, totalBytes);\n    }\n}\nasync function install(archivePath, folderPath) {\n    debugFetcher(`Installing ${archivePath} to ${folderPath}`);\n    if (archivePath.endsWith('.zip')) {\n        await extractZip(archivePath, { dir: folderPath });\n    }\n    else if (archivePath.endsWith('.tar.bz2')) {\n        await extractTar(archivePath, folderPath);\n    }\n    else if (archivePath.endsWith('.dmg')) {\n        await mkdir(folderPath);\n        await installDMG(archivePath, folderPath);\n    }\n    else {\n        throw new Error(`Unsupported archive format: ${archivePath}`);\n    }\n}\n/**\n * @internal\n */\nfunction extractTar(tarPath, folderPath) {\n    return new Promise((fulfill, reject) => {\n        const tarStream = tar.extract(folderPath);\n        tarStream.on('error', reject);\n        tarStream.on('finish', fulfill);\n        const readStream = createReadStream(tarPath);\n        readStream.pipe(bzip()).pipe(tarStream);\n    });\n}\n/**\n * @internal\n */\nasync function installDMG(dmgPath, folderPath) {\n    const { stdout } = await exec(`hdiutil attach -nobrowse -noautoopen \"${dmgPath}\"`);\n    const volumes = stdout.match(/\\/Volumes\\/(.*)/m);\n    if (!volumes) {\n        throw new Error(`Could not find volume path in ${stdout}`);\n    }\n    const mountPath = volumes[0];\n    try {\n        const fileNames = await readdir(mountPath);\n        const appName = fileNames.find(item => {\n            return typeof item === 'string' && item.endsWith('.app');\n        });\n        if (!appName) {\n            throw new Error(`Cannot find app in ${mountPath}`);\n        }\n        const mountedPath = path.join(mountPath, appName);\n        debugFetcher(`Copying ${mountedPath} to ${folderPath}`);\n        await exec(`cp -R \"${mountedPath}\" \"${folderPath}\"`);\n    }\n    finally {\n        debugFetcher(`Unmounting ${mountPath}`);\n        await exec(`hdiutil detach \"${mountPath}\" -quiet`);\n    }\n}\nfunction httpRequest(url, method, response, keepAlive = true) {\n    const urlParsed = URL.parse(url);\n    let options = {\n        ...urlParsed,\n        method,\n        headers: keepAlive ? { Connection: 'keep-alive' } : undefined,\n    };\n    const proxyURL = getProxyForUrl(url);\n    if (proxyURL) {\n        if (url.startsWith('http:')) {\n            const proxy = URL.parse(proxyURL);\n            options = {\n                path: options.href,\n                host: proxy.hostname,\n                port: proxy.port,\n            };\n        }\n        else {\n            const parsedProxyURL = URL.parse(proxyURL);\n            const proxyOptions = {\n                ...parsedProxyURL,\n                secureProxy: parsedProxyURL.protocol === 'https:',\n            };\n            options.agent = createHttpsProxyAgent(proxyOptions);\n            options.rejectUnauthorized = false;\n        }\n    }\n    const requestCallback = (res) => {\n        if (res.statusCode &&\n            res.statusCode >= 300 &&\n            res.statusCode < 400 &&\n            res.headers.location) {\n            httpRequest(res.headers.location, method, response);\n        }\n        else {\n            response(res);\n        }\n    };\n    const request = options.protocol === 'https:'\n        ? https.request(options, requestCallback)\n        : http.request(options, requestCallback);\n    request.end();\n    return request;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}