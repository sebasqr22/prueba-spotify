{"ast":null,"code":"import _asyncToGenerator from \"/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Callback_id, _Callback_error, _Callback_promise, _Callback_timer, _Callback_label, _CallbackRegistry_callbacks, _CallbackRegistry_idGenerator, _Connection_instances, _Connection_url, _Connection_transport, _Connection_delay, _Connection_timeout, _Connection_sessions, _Connection_closed, _Connection_manuallyAttached, _Connection_callbacks, _Connection_onClose, _CDPSessionImpl_sessionId, _CDPSessionImpl_targetType, _CDPSessionImpl_callbacks, _CDPSessionImpl_connection;\nimport { assert } from '../util/assert.js';\nimport { createDeferredPromise } from '../util/util.js';\nimport { debug } from './Debug.js';\nimport { ProtocolError } from './Errors.js';\nimport { EventEmitter } from './EventEmitter.js';\nconst debugProtocolSend = debug('puppeteer:protocol:SEND ►');\nconst debugProtocolReceive = debug('puppeteer:protocol:RECV ◀');\n/**\n * Internal events that the Connection class emits.\n *\n * @internal\n */\nexport const ConnectionEmittedEvents = {\n  Disconnected: Symbol('Connection.Disconnected')\n};\n/**\n * @internal\n */\nfunction createIncrementalIdGenerator() {\n  let id = 0;\n  return () => {\n    return ++id;\n  };\n}\n/**\n * @internal\n */\nclass Callback {\n  constructor(id, label, timeout) {\n    _Callback_id.set(this, void 0);\n    _Callback_error.set(this, new ProtocolError());\n    _Callback_promise.set(this, createDeferredPromise());\n    _Callback_timer.set(this, void 0);\n    _Callback_label.set(this, void 0);\n    __classPrivateFieldSet(this, _Callback_id, id, \"f\");\n    __classPrivateFieldSet(this, _Callback_label, label, \"f\");\n    if (timeout) {\n      __classPrivateFieldSet(this, _Callback_timer, setTimeout(() => {\n        __classPrivateFieldGet(this, _Callback_promise, \"f\").reject(rewriteError(__classPrivateFieldGet(this, _Callback_error, \"f\"), `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));\n      }, timeout), \"f\");\n    }\n  }\n  resolve(value) {\n    clearTimeout(__classPrivateFieldGet(this, _Callback_timer, \"f\"));\n    __classPrivateFieldGet(this, _Callback_promise, \"f\").resolve(value);\n  }\n  reject(error) {\n    clearTimeout(__classPrivateFieldGet(this, _Callback_timer, \"f\"));\n    __classPrivateFieldGet(this, _Callback_promise, \"f\").reject(error);\n  }\n  get id() {\n    return __classPrivateFieldGet(this, _Callback_id, \"f\");\n  }\n  get promise() {\n    return __classPrivateFieldGet(this, _Callback_promise, \"f\");\n  }\n  get error() {\n    return __classPrivateFieldGet(this, _Callback_error, \"f\");\n  }\n  get label() {\n    return __classPrivateFieldGet(this, _Callback_label, \"f\");\n  }\n}\n_Callback_id = new WeakMap(), _Callback_error = new WeakMap(), _Callback_promise = new WeakMap(), _Callback_timer = new WeakMap(), _Callback_label = new WeakMap();\n/**\n * Manages callbacks and their IDs for the protocol request/response communication.\n *\n * @internal\n */\nexport class CallbackRegistry {\n  constructor() {\n    _CallbackRegistry_callbacks.set(this, new Map());\n    _CallbackRegistry_idGenerator.set(this, createIncrementalIdGenerator());\n  }\n  create(label, timeout, request) {\n    const callback = new Callback(__classPrivateFieldGet(this, _CallbackRegistry_idGenerator, \"f\").call(this), label, timeout);\n    __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").set(callback.id, callback);\n    try {\n      request(callback.id);\n    } catch (error) {\n      // We still throw sync errors synchronously and clean up the scheduled\n      // callback.\n      callback.promise.catch(() => {\n        __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").delete(callback.id);\n      });\n      callback.reject(error);\n      throw error;\n    }\n    // Must only have sync code up until here.\n    return callback.promise.finally(() => {\n      __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").delete(callback.id);\n    });\n  }\n  reject(id, message, originalMessage) {\n    const callback = __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").get(id);\n    if (!callback) {\n      return;\n    }\n    this._reject(callback, message, originalMessage);\n  }\n  _reject(callback, message, originalMessage) {\n    callback.reject(rewriteError(callback.error, `Protocol error (${callback.label}): ${message}`, originalMessage));\n  }\n  resolve(id, value) {\n    const callback = __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").get(id);\n    if (!callback) {\n      return;\n    }\n    callback.resolve(value);\n  }\n  clear() {\n    for (const callback of __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").values()) {\n      // TODO: probably we can accept error messages as params.\n      this._reject(callback, 'Target closed');\n    }\n    __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").clear();\n  }\n}\n_CallbackRegistry_callbacks = new WeakMap(), _CallbackRegistry_idGenerator = new WeakMap();\n/**\n * @public\n */\nexport class Connection extends EventEmitter {\n  constructor(url, transport, delay = 0, timeout) {\n    super();\n    _Connection_instances.add(this);\n    _Connection_url.set(this, void 0);\n    _Connection_transport.set(this, void 0);\n    _Connection_delay.set(this, void 0);\n    _Connection_timeout.set(this, void 0);\n    _Connection_sessions.set(this, new Map());\n    _Connection_closed.set(this, false);\n    _Connection_manuallyAttached.set(this, new Set());\n    _Connection_callbacks.set(this, new CallbackRegistry());\n    __classPrivateFieldSet(this, _Connection_url, url, \"f\");\n    __classPrivateFieldSet(this, _Connection_delay, delay, \"f\");\n    __classPrivateFieldSet(this, _Connection_timeout, timeout !== null && timeout !== void 0 ? timeout : 180000, \"f\");\n    __classPrivateFieldSet(this, _Connection_transport, transport, \"f\");\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").onmessage = this.onMessage.bind(this);\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").onclose = __classPrivateFieldGet(this, _Connection_instances, \"m\", _Connection_onClose).bind(this);\n  }\n  static fromSession(session) {\n    return session.connection();\n  }\n  get timeout() {\n    return __classPrivateFieldGet(this, _Connection_timeout, \"f\");\n  }\n  /**\n   * @internal\n   */\n  get _closed() {\n    return __classPrivateFieldGet(this, _Connection_closed, \"f\");\n  }\n  /**\n   * @internal\n   */\n  get _sessions() {\n    return __classPrivateFieldGet(this, _Connection_sessions, \"f\");\n  }\n  /**\n   * @param sessionId - The session id\n   * @returns The current CDP session if it exists\n   */\n  session(sessionId) {\n    return __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(sessionId) || null;\n  }\n  url() {\n    return __classPrivateFieldGet(this, _Connection_url, \"f\");\n  }\n  send(method, ...paramArgs) {\n    // There is only ever 1 param arg passed, but the Protocol defines it as an\n    // array of 0 or 1 items See this comment:\n    // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285\n    // which explains why the protocol defines the params this way for better\n    // type-inference.\n    // So now we check if there are any params or not and deal with them accordingly.\n    const params = paramArgs.length ? paramArgs[0] : undefined;\n    return this._rawSend(__classPrivateFieldGet(this, _Connection_callbacks, \"f\"), method, params);\n  }\n  /**\n   * @internal\n   */\n  _rawSend(callbacks, method, params, sessionId) {\n    return callbacks.create(method, __classPrivateFieldGet(this, _Connection_timeout, \"f\"), id => {\n      const stringifiedMessage = JSON.stringify({\n        method,\n        params,\n        id,\n        sessionId\n      });\n      debugProtocolSend(stringifiedMessage);\n      __classPrivateFieldGet(this, _Connection_transport, \"f\").send(stringifiedMessage);\n    });\n  }\n  /**\n   * @internal\n   */\n  closeBrowser() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield _this.send('Browser.close');\n    })();\n  }\n  /**\n   * @internal\n   */\n  onMessage(message) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (__classPrivateFieldGet(_this2, _Connection_delay, \"f\")) {\n        yield new Promise(f => {\n          return setTimeout(f, __classPrivateFieldGet(_this2, _Connection_delay, \"f\"));\n        });\n      }\n      debugProtocolReceive(message);\n      const object = JSON.parse(message);\n      if (object.method === 'Target.attachedToTarget') {\n        const sessionId = object.params.sessionId;\n        const session = new CDPSessionImpl(_this2, object.params.targetInfo.type, sessionId);\n        __classPrivateFieldGet(_this2, _Connection_sessions, \"f\").set(sessionId, session);\n        _this2.emit('sessionattached', session);\n        const parentSession = __classPrivateFieldGet(_this2, _Connection_sessions, \"f\").get(object.sessionId);\n        if (parentSession) {\n          parentSession.emit('sessionattached', session);\n        }\n      } else if (object.method === 'Target.detachedFromTarget') {\n        const session = __classPrivateFieldGet(_this2, _Connection_sessions, \"f\").get(object.params.sessionId);\n        if (session) {\n          session._onClosed();\n          __classPrivateFieldGet(_this2, _Connection_sessions, \"f\").delete(object.params.sessionId);\n          _this2.emit('sessiondetached', session);\n          const parentSession = __classPrivateFieldGet(_this2, _Connection_sessions, \"f\").get(object.sessionId);\n          if (parentSession) {\n            parentSession.emit('sessiondetached', session);\n          }\n        }\n      }\n      if (object.sessionId) {\n        const session = __classPrivateFieldGet(_this2, _Connection_sessions, \"f\").get(object.sessionId);\n        if (session) {\n          session._onMessage(object);\n        }\n      } else if (object.id) {\n        if (object.error) {\n          __classPrivateFieldGet(_this2, _Connection_callbacks, \"f\").reject(object.id, createProtocolErrorMessage(object), object.error.message);\n        } else {\n          __classPrivateFieldGet(_this2, _Connection_callbacks, \"f\").resolve(object.id, object.result);\n        }\n      } else {\n        _this2.emit(object.method, object.params);\n      }\n    })();\n  }\n  dispose() {\n    __classPrivateFieldGet(this, _Connection_instances, \"m\", _Connection_onClose).call(this);\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").close();\n  }\n  /**\n   * @internal\n   */\n  isAutoAttached(targetId) {\n    return !__classPrivateFieldGet(this, _Connection_manuallyAttached, \"f\").has(targetId);\n  }\n  /**\n   * @internal\n   */\n  _createSession(targetInfo, isAutoAttachEmulated = true) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!isAutoAttachEmulated) {\n        __classPrivateFieldGet(_this3, _Connection_manuallyAttached, \"f\").add(targetInfo.targetId);\n      }\n      const {\n        sessionId\n      } = yield _this3.send('Target.attachToTarget', {\n        targetId: targetInfo.targetId,\n        flatten: true\n      });\n      __classPrivateFieldGet(_this3, _Connection_manuallyAttached, \"f\").delete(targetInfo.targetId);\n      const session = __classPrivateFieldGet(_this3, _Connection_sessions, \"f\").get(sessionId);\n      if (!session) {\n        throw new Error('CDPSession creation failed.');\n      }\n      return session;\n    })();\n  }\n  /**\n   * @param targetInfo - The target info\n   * @returns The CDP session that is created\n   */\n  createSession(targetInfo) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this4._createSession(targetInfo, false);\n    })();\n  }\n}\n_Connection_url = new WeakMap(), _Connection_transport = new WeakMap(), _Connection_delay = new WeakMap(), _Connection_timeout = new WeakMap(), _Connection_sessions = new WeakMap(), _Connection_closed = new WeakMap(), _Connection_manuallyAttached = new WeakMap(), _Connection_callbacks = new WeakMap(), _Connection_instances = new WeakSet(), _Connection_onClose = function _Connection_onClose() {\n  if (__classPrivateFieldGet(this, _Connection_closed, \"f\")) {\n    return;\n  }\n  __classPrivateFieldSet(this, _Connection_closed, true, \"f\");\n  __classPrivateFieldGet(this, _Connection_transport, \"f\").onmessage = undefined;\n  __classPrivateFieldGet(this, _Connection_transport, \"f\").onclose = undefined;\n  __classPrivateFieldGet(this, _Connection_callbacks, \"f\").clear();\n  for (const session of __classPrivateFieldGet(this, _Connection_sessions, \"f\").values()) {\n    session._onClosed();\n  }\n  __classPrivateFieldGet(this, _Connection_sessions, \"f\").clear();\n  this.emit(ConnectionEmittedEvents.Disconnected);\n};\n/**\n * Internal events that the CDPSession class emits.\n *\n * @internal\n */\nexport const CDPSessionEmittedEvents = {\n  Disconnected: Symbol('CDPSession.Disconnected')\n};\n/**\n * The `CDPSession` instances are used to talk raw Chrome Devtools Protocol.\n *\n * @remarks\n *\n * Protocol methods can be called with {@link CDPSession.send} method and protocol\n * events can be subscribed to with `CDPSession.on` method.\n *\n * Useful links: {@link https://chromedevtools.github.io/devtools-protocol/ | DevTools Protocol Viewer}\n * and {@link https://github.com/aslushnikov/getting-started-with-cdp/blob/HEAD/README.md | Getting Started with DevTools Protocol}.\n *\n * @example\n *\n * ```ts\n * const client = await page.target().createCDPSession();\n * await client.send('Animation.enable');\n * client.on('Animation.animationCreated', () =>\n *   console.log('Animation created!')\n * );\n * const response = await client.send('Animation.getPlaybackRate');\n * console.log('playback rate is ' + response.playbackRate);\n * await client.send('Animation.setPlaybackRate', {\n *   playbackRate: response.playbackRate / 2,\n * });\n * ```\n *\n * @public\n */\nexport class CDPSession extends EventEmitter {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n  connection() {\n    throw new Error('Not implemented');\n  }\n  send() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Detaches the cdpSession from the target. Once detached, the cdpSession object\n   * won't emit any events and can't be used to send messages.\n   */\n  detach() {\n    return _asyncToGenerator(function* () {\n      throw new Error('Not implemented');\n    })();\n  }\n  /**\n   * Returns the session's id.\n   */\n  id() {\n    throw new Error('Not implemented');\n  }\n}\n/**\n * @internal\n */\nexport class CDPSessionImpl extends CDPSession {\n  /**\n   * @internal\n   */\n  constructor(connection, targetType, sessionId) {\n    super();\n    _CDPSessionImpl_sessionId.set(this, void 0);\n    _CDPSessionImpl_targetType.set(this, void 0);\n    _CDPSessionImpl_callbacks.set(this, new CallbackRegistry());\n    _CDPSessionImpl_connection.set(this, void 0);\n    __classPrivateFieldSet(this, _CDPSessionImpl_connection, connection, \"f\");\n    __classPrivateFieldSet(this, _CDPSessionImpl_targetType, targetType, \"f\");\n    __classPrivateFieldSet(this, _CDPSessionImpl_sessionId, sessionId, \"f\");\n  }\n  connection() {\n    return __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\");\n  }\n  send(method, ...paramArgs) {\n    if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")) {\n      return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, \"f\")} has been closed.`));\n    }\n    // See the comment in Connection#send explaining why we do this.\n    const params = paramArgs.length ? paramArgs[0] : undefined;\n    return __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")._rawSend(__classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\"), method, params, __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\"));\n  }\n  /**\n   * @internal\n   */\n  _onMessage(object) {\n    if (object.id) {\n      if (object.error) {\n        __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").reject(object.id, createProtocolErrorMessage(object), object.error.message);\n      } else {\n        __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").resolve(object.id, object.result);\n      }\n    } else {\n      assert(!object.id);\n      this.emit(object.method, object.params);\n    }\n  }\n  /**\n   * Detaches the cdpSession from the target. Once detached, the cdpSession object\n   * won't emit any events and can't be used to send messages.\n   */\n  detach() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (!__classPrivateFieldGet(_this5, _CDPSessionImpl_connection, \"f\")) {\n        throw new Error(`Session already detached. Most likely the ${__classPrivateFieldGet(_this5, _CDPSessionImpl_targetType, \"f\")} has been closed.`);\n      }\n      yield __classPrivateFieldGet(_this5, _CDPSessionImpl_connection, \"f\").send('Target.detachFromTarget', {\n        sessionId: __classPrivateFieldGet(_this5, _CDPSessionImpl_sessionId, \"f\")\n      });\n    })();\n  }\n  /**\n   * @internal\n   */\n  _onClosed() {\n    __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").clear();\n    __classPrivateFieldSet(this, _CDPSessionImpl_connection, undefined, \"f\");\n    this.emit(CDPSessionEmittedEvents.Disconnected);\n  }\n  /**\n   * Returns the session's id.\n   */\n  id() {\n    return __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\");\n  }\n}\n_CDPSessionImpl_sessionId = new WeakMap(), _CDPSessionImpl_targetType = new WeakMap(), _CDPSessionImpl_callbacks = new WeakMap(), _CDPSessionImpl_connection = new WeakMap();\nfunction createProtocolErrorMessage(object) {\n  let message = `${object.error.message}`;\n  if ('data' in object.error) {\n    message += ` ${object.error.data}`;\n  }\n  return message;\n}\nfunction rewriteError(error, message, originalMessage) {\n  error.message = message;\n  error.originalMessage = originalMessage !== null && originalMessage !== void 0 ? originalMessage : error.originalMessage;\n  return error;\n}\n/**\n * @internal\n */\nexport function isTargetClosedError(err) {\n  return err.message.includes('Target closed') || err.message.includes('Session closed');\n}","map":{"version":3,"names":["__classPrivateFieldSet","receiver","state","value","kind","f","TypeError","has","call","set","__classPrivateFieldGet","get","_Callback_id","_Callback_error","_Callback_promise","_Callback_timer","_Callback_label","_CallbackRegistry_callbacks","_CallbackRegistry_idGenerator","_Connection_instances","_Connection_url","_Connection_transport","_Connection_delay","_Connection_timeout","_Connection_sessions","_Connection_closed","_Connection_manuallyAttached","_Connection_callbacks","_Connection_onClose","_CDPSessionImpl_sessionId","_CDPSessionImpl_targetType","_CDPSessionImpl_callbacks","_CDPSessionImpl_connection","assert","createDeferredPromise","debug","ProtocolError","EventEmitter","debugProtocolSend","debugProtocolReceive","ConnectionEmittedEvents","Disconnected","Symbol","createIncrementalIdGenerator","id","Callback","constructor","label","timeout","setTimeout","reject","rewriteError","resolve","clearTimeout","error","promise","WeakMap","CallbackRegistry","Map","create","request","callback","catch","delete","finally","message","originalMessage","_reject","clear","values","Connection","url","transport","delay","add","Set","onmessage","onMessage","bind","onclose","fromSession","session","connection","_closed","_sessions","sessionId","send","method","paramArgs","params","length","undefined","_rawSend","callbacks","stringifiedMessage","JSON","stringify","closeBrowser","Promise","object","parse","CDPSessionImpl","targetInfo","type","emit","parentSession","_onClosed","_onMessage","createProtocolErrorMessage","result","dispose","close","isAutoAttached","targetId","_createSession","isAutoAttachEmulated","flatten","Error","createSession","WeakSet","CDPSessionEmittedEvents","CDPSession","detach","targetType","data","isTargetClosedError","err","includes"],"sources":["/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/puppeteer-core/lib/esm/puppeteer/common/Connection.js"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Callback_id, _Callback_error, _Callback_promise, _Callback_timer, _Callback_label, _CallbackRegistry_callbacks, _CallbackRegistry_idGenerator, _Connection_instances, _Connection_url, _Connection_transport, _Connection_delay, _Connection_timeout, _Connection_sessions, _Connection_closed, _Connection_manuallyAttached, _Connection_callbacks, _Connection_onClose, _CDPSessionImpl_sessionId, _CDPSessionImpl_targetType, _CDPSessionImpl_callbacks, _CDPSessionImpl_connection;\nimport { assert } from '../util/assert.js';\nimport { createDeferredPromise } from '../util/util.js';\nimport { debug } from './Debug.js';\nimport { ProtocolError } from './Errors.js';\nimport { EventEmitter } from './EventEmitter.js';\nconst debugProtocolSend = debug('puppeteer:protocol:SEND ►');\nconst debugProtocolReceive = debug('puppeteer:protocol:RECV ◀');\n/**\n * Internal events that the Connection class emits.\n *\n * @internal\n */\nexport const ConnectionEmittedEvents = {\n    Disconnected: Symbol('Connection.Disconnected'),\n};\n/**\n * @internal\n */\nfunction createIncrementalIdGenerator() {\n    let id = 0;\n    return () => {\n        return ++id;\n    };\n}\n/**\n * @internal\n */\nclass Callback {\n    constructor(id, label, timeout) {\n        _Callback_id.set(this, void 0);\n        _Callback_error.set(this, new ProtocolError());\n        _Callback_promise.set(this, createDeferredPromise());\n        _Callback_timer.set(this, void 0);\n        _Callback_label.set(this, void 0);\n        __classPrivateFieldSet(this, _Callback_id, id, \"f\");\n        __classPrivateFieldSet(this, _Callback_label, label, \"f\");\n        if (timeout) {\n            __classPrivateFieldSet(this, _Callback_timer, setTimeout(() => {\n                __classPrivateFieldGet(this, _Callback_promise, \"f\").reject(rewriteError(__classPrivateFieldGet(this, _Callback_error, \"f\"), `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));\n            }, timeout), \"f\");\n        }\n    }\n    resolve(value) {\n        clearTimeout(__classPrivateFieldGet(this, _Callback_timer, \"f\"));\n        __classPrivateFieldGet(this, _Callback_promise, \"f\").resolve(value);\n    }\n    reject(error) {\n        clearTimeout(__classPrivateFieldGet(this, _Callback_timer, \"f\"));\n        __classPrivateFieldGet(this, _Callback_promise, \"f\").reject(error);\n    }\n    get id() {\n        return __classPrivateFieldGet(this, _Callback_id, \"f\");\n    }\n    get promise() {\n        return __classPrivateFieldGet(this, _Callback_promise, \"f\");\n    }\n    get error() {\n        return __classPrivateFieldGet(this, _Callback_error, \"f\");\n    }\n    get label() {\n        return __classPrivateFieldGet(this, _Callback_label, \"f\");\n    }\n}\n_Callback_id = new WeakMap(), _Callback_error = new WeakMap(), _Callback_promise = new WeakMap(), _Callback_timer = new WeakMap(), _Callback_label = new WeakMap();\n/**\n * Manages callbacks and their IDs for the protocol request/response communication.\n *\n * @internal\n */\nexport class CallbackRegistry {\n    constructor() {\n        _CallbackRegistry_callbacks.set(this, new Map());\n        _CallbackRegistry_idGenerator.set(this, createIncrementalIdGenerator());\n    }\n    create(label, timeout, request) {\n        const callback = new Callback(__classPrivateFieldGet(this, _CallbackRegistry_idGenerator, \"f\").call(this), label, timeout);\n        __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").set(callback.id, callback);\n        try {\n            request(callback.id);\n        }\n        catch (error) {\n            // We still throw sync errors synchronously and clean up the scheduled\n            // callback.\n            callback.promise.catch(() => {\n                __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").delete(callback.id);\n            });\n            callback.reject(error);\n            throw error;\n        }\n        // Must only have sync code up until here.\n        return callback.promise.finally(() => {\n            __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").delete(callback.id);\n        });\n    }\n    reject(id, message, originalMessage) {\n        const callback = __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").get(id);\n        if (!callback) {\n            return;\n        }\n        this._reject(callback, message, originalMessage);\n    }\n    _reject(callback, message, originalMessage) {\n        callback.reject(rewriteError(callback.error, `Protocol error (${callback.label}): ${message}`, originalMessage));\n    }\n    resolve(id, value) {\n        const callback = __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").get(id);\n        if (!callback) {\n            return;\n        }\n        callback.resolve(value);\n    }\n    clear() {\n        for (const callback of __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").values()) {\n            // TODO: probably we can accept error messages as params.\n            this._reject(callback, 'Target closed');\n        }\n        __classPrivateFieldGet(this, _CallbackRegistry_callbacks, \"f\").clear();\n    }\n}\n_CallbackRegistry_callbacks = new WeakMap(), _CallbackRegistry_idGenerator = new WeakMap();\n/**\n * @public\n */\nexport class Connection extends EventEmitter {\n    constructor(url, transport, delay = 0, timeout) {\n        super();\n        _Connection_instances.add(this);\n        _Connection_url.set(this, void 0);\n        _Connection_transport.set(this, void 0);\n        _Connection_delay.set(this, void 0);\n        _Connection_timeout.set(this, void 0);\n        _Connection_sessions.set(this, new Map());\n        _Connection_closed.set(this, false);\n        _Connection_manuallyAttached.set(this, new Set());\n        _Connection_callbacks.set(this, new CallbackRegistry());\n        __classPrivateFieldSet(this, _Connection_url, url, \"f\");\n        __classPrivateFieldSet(this, _Connection_delay, delay, \"f\");\n        __classPrivateFieldSet(this, _Connection_timeout, timeout !== null && timeout !== void 0 ? timeout : 180000, \"f\");\n        __classPrivateFieldSet(this, _Connection_transport, transport, \"f\");\n        __classPrivateFieldGet(this, _Connection_transport, \"f\").onmessage = this.onMessage.bind(this);\n        __classPrivateFieldGet(this, _Connection_transport, \"f\").onclose = __classPrivateFieldGet(this, _Connection_instances, \"m\", _Connection_onClose).bind(this);\n    }\n    static fromSession(session) {\n        return session.connection();\n    }\n    get timeout() {\n        return __classPrivateFieldGet(this, _Connection_timeout, \"f\");\n    }\n    /**\n     * @internal\n     */\n    get _closed() {\n        return __classPrivateFieldGet(this, _Connection_closed, \"f\");\n    }\n    /**\n     * @internal\n     */\n    get _sessions() {\n        return __classPrivateFieldGet(this, _Connection_sessions, \"f\");\n    }\n    /**\n     * @param sessionId - The session id\n     * @returns The current CDP session if it exists\n     */\n    session(sessionId) {\n        return __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(sessionId) || null;\n    }\n    url() {\n        return __classPrivateFieldGet(this, _Connection_url, \"f\");\n    }\n    send(method, ...paramArgs) {\n        // There is only ever 1 param arg passed, but the Protocol defines it as an\n        // array of 0 or 1 items See this comment:\n        // https://github.com/ChromeDevTools/devtools-protocol/pull/113#issuecomment-412603285\n        // which explains why the protocol defines the params this way for better\n        // type-inference.\n        // So now we check if there are any params or not and deal with them accordingly.\n        const params = paramArgs.length ? paramArgs[0] : undefined;\n        return this._rawSend(__classPrivateFieldGet(this, _Connection_callbacks, \"f\"), method, params);\n    }\n    /**\n     * @internal\n     */\n    _rawSend(callbacks, method, params, sessionId) {\n        return callbacks.create(method, __classPrivateFieldGet(this, _Connection_timeout, \"f\"), id => {\n            const stringifiedMessage = JSON.stringify({\n                method,\n                params,\n                id,\n                sessionId,\n            });\n            debugProtocolSend(stringifiedMessage);\n            __classPrivateFieldGet(this, _Connection_transport, \"f\").send(stringifiedMessage);\n        });\n    }\n    /**\n     * @internal\n     */\n    async closeBrowser() {\n        await this.send('Browser.close');\n    }\n    /**\n     * @internal\n     */\n    async onMessage(message) {\n        if (__classPrivateFieldGet(this, _Connection_delay, \"f\")) {\n            await new Promise(f => {\n                return setTimeout(f, __classPrivateFieldGet(this, _Connection_delay, \"f\"));\n            });\n        }\n        debugProtocolReceive(message);\n        const object = JSON.parse(message);\n        if (object.method === 'Target.attachedToTarget') {\n            const sessionId = object.params.sessionId;\n            const session = new CDPSessionImpl(this, object.params.targetInfo.type, sessionId);\n            __classPrivateFieldGet(this, _Connection_sessions, \"f\").set(sessionId, session);\n            this.emit('sessionattached', session);\n            const parentSession = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.sessionId);\n            if (parentSession) {\n                parentSession.emit('sessionattached', session);\n            }\n        }\n        else if (object.method === 'Target.detachedFromTarget') {\n            const session = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.params.sessionId);\n            if (session) {\n                session._onClosed();\n                __classPrivateFieldGet(this, _Connection_sessions, \"f\").delete(object.params.sessionId);\n                this.emit('sessiondetached', session);\n                const parentSession = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.sessionId);\n                if (parentSession) {\n                    parentSession.emit('sessiondetached', session);\n                }\n            }\n        }\n        if (object.sessionId) {\n            const session = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(object.sessionId);\n            if (session) {\n                session._onMessage(object);\n            }\n        }\n        else if (object.id) {\n            if (object.error) {\n                __classPrivateFieldGet(this, _Connection_callbacks, \"f\").reject(object.id, createProtocolErrorMessage(object), object.error.message);\n            }\n            else {\n                __classPrivateFieldGet(this, _Connection_callbacks, \"f\").resolve(object.id, object.result);\n            }\n        }\n        else {\n            this.emit(object.method, object.params);\n        }\n    }\n    dispose() {\n        __classPrivateFieldGet(this, _Connection_instances, \"m\", _Connection_onClose).call(this);\n        __classPrivateFieldGet(this, _Connection_transport, \"f\").close();\n    }\n    /**\n     * @internal\n     */\n    isAutoAttached(targetId) {\n        return !__classPrivateFieldGet(this, _Connection_manuallyAttached, \"f\").has(targetId);\n    }\n    /**\n     * @internal\n     */\n    async _createSession(targetInfo, isAutoAttachEmulated = true) {\n        if (!isAutoAttachEmulated) {\n            __classPrivateFieldGet(this, _Connection_manuallyAttached, \"f\").add(targetInfo.targetId);\n        }\n        const { sessionId } = await this.send('Target.attachToTarget', {\n            targetId: targetInfo.targetId,\n            flatten: true,\n        });\n        __classPrivateFieldGet(this, _Connection_manuallyAttached, \"f\").delete(targetInfo.targetId);\n        const session = __classPrivateFieldGet(this, _Connection_sessions, \"f\").get(sessionId);\n        if (!session) {\n            throw new Error('CDPSession creation failed.');\n        }\n        return session;\n    }\n    /**\n     * @param targetInfo - The target info\n     * @returns The CDP session that is created\n     */\n    async createSession(targetInfo) {\n        return await this._createSession(targetInfo, false);\n    }\n}\n_Connection_url = new WeakMap(), _Connection_transport = new WeakMap(), _Connection_delay = new WeakMap(), _Connection_timeout = new WeakMap(), _Connection_sessions = new WeakMap(), _Connection_closed = new WeakMap(), _Connection_manuallyAttached = new WeakMap(), _Connection_callbacks = new WeakMap(), _Connection_instances = new WeakSet(), _Connection_onClose = function _Connection_onClose() {\n    if (__classPrivateFieldGet(this, _Connection_closed, \"f\")) {\n        return;\n    }\n    __classPrivateFieldSet(this, _Connection_closed, true, \"f\");\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").onmessage = undefined;\n    __classPrivateFieldGet(this, _Connection_transport, \"f\").onclose = undefined;\n    __classPrivateFieldGet(this, _Connection_callbacks, \"f\").clear();\n    for (const session of __classPrivateFieldGet(this, _Connection_sessions, \"f\").values()) {\n        session._onClosed();\n    }\n    __classPrivateFieldGet(this, _Connection_sessions, \"f\").clear();\n    this.emit(ConnectionEmittedEvents.Disconnected);\n};\n/**\n * Internal events that the CDPSession class emits.\n *\n * @internal\n */\nexport const CDPSessionEmittedEvents = {\n    Disconnected: Symbol('CDPSession.Disconnected'),\n};\n/**\n * The `CDPSession` instances are used to talk raw Chrome Devtools Protocol.\n *\n * @remarks\n *\n * Protocol methods can be called with {@link CDPSession.send} method and protocol\n * events can be subscribed to with `CDPSession.on` method.\n *\n * Useful links: {@link https://chromedevtools.github.io/devtools-protocol/ | DevTools Protocol Viewer}\n * and {@link https://github.com/aslushnikov/getting-started-with-cdp/blob/HEAD/README.md | Getting Started with DevTools Protocol}.\n *\n * @example\n *\n * ```ts\n * const client = await page.target().createCDPSession();\n * await client.send('Animation.enable');\n * client.on('Animation.animationCreated', () =>\n *   console.log('Animation created!')\n * );\n * const response = await client.send('Animation.getPlaybackRate');\n * console.log('playback rate is ' + response.playbackRate);\n * await client.send('Animation.setPlaybackRate', {\n *   playbackRate: response.playbackRate / 2,\n * });\n * ```\n *\n * @public\n */\nexport class CDPSession extends EventEmitter {\n    /**\n     * @internal\n     */\n    constructor() {\n        super();\n    }\n    connection() {\n        throw new Error('Not implemented');\n    }\n    send() {\n        throw new Error('Not implemented');\n    }\n    /**\n     * Detaches the cdpSession from the target. Once detached, the cdpSession object\n     * won't emit any events and can't be used to send messages.\n     */\n    async detach() {\n        throw new Error('Not implemented');\n    }\n    /**\n     * Returns the session's id.\n     */\n    id() {\n        throw new Error('Not implemented');\n    }\n}\n/**\n * @internal\n */\nexport class CDPSessionImpl extends CDPSession {\n    /**\n     * @internal\n     */\n    constructor(connection, targetType, sessionId) {\n        super();\n        _CDPSessionImpl_sessionId.set(this, void 0);\n        _CDPSessionImpl_targetType.set(this, void 0);\n        _CDPSessionImpl_callbacks.set(this, new CallbackRegistry());\n        _CDPSessionImpl_connection.set(this, void 0);\n        __classPrivateFieldSet(this, _CDPSessionImpl_connection, connection, \"f\");\n        __classPrivateFieldSet(this, _CDPSessionImpl_targetType, targetType, \"f\");\n        __classPrivateFieldSet(this, _CDPSessionImpl_sessionId, sessionId, \"f\");\n    }\n    connection() {\n        return __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\");\n    }\n    send(method, ...paramArgs) {\n        if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")) {\n            return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, \"f\")} has been closed.`));\n        }\n        // See the comment in Connection#send explaining why we do this.\n        const params = paramArgs.length ? paramArgs[0] : undefined;\n        return __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")._rawSend(__classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\"), method, params, __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\"));\n    }\n    /**\n     * @internal\n     */\n    _onMessage(object) {\n        if (object.id) {\n            if (object.error) {\n                __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").reject(object.id, createProtocolErrorMessage(object), object.error.message);\n            }\n            else {\n                __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").resolve(object.id, object.result);\n            }\n        }\n        else {\n            assert(!object.id);\n            this.emit(object.method, object.params);\n        }\n    }\n    /**\n     * Detaches the cdpSession from the target. Once detached, the cdpSession object\n     * won't emit any events and can't be used to send messages.\n     */\n    async detach() {\n        if (!__classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\")) {\n            throw new Error(`Session already detached. Most likely the ${__classPrivateFieldGet(this, _CDPSessionImpl_targetType, \"f\")} has been closed.`);\n        }\n        await __classPrivateFieldGet(this, _CDPSessionImpl_connection, \"f\").send('Target.detachFromTarget', {\n            sessionId: __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\"),\n        });\n    }\n    /**\n     * @internal\n     */\n    _onClosed() {\n        __classPrivateFieldGet(this, _CDPSessionImpl_callbacks, \"f\").clear();\n        __classPrivateFieldSet(this, _CDPSessionImpl_connection, undefined, \"f\");\n        this.emit(CDPSessionEmittedEvents.Disconnected);\n    }\n    /**\n     * Returns the session's id.\n     */\n    id() {\n        return __classPrivateFieldGet(this, _CDPSessionImpl_sessionId, \"f\");\n    }\n}\n_CDPSessionImpl_sessionId = new WeakMap(), _CDPSessionImpl_targetType = new WeakMap(), _CDPSessionImpl_callbacks = new WeakMap(), _CDPSessionImpl_connection = new WeakMap();\nfunction createProtocolErrorMessage(object) {\n    let message = `${object.error.message}`;\n    if ('data' in object.error) {\n        message += ` ${object.error.data}`;\n    }\n    return message;\n}\nfunction rewriteError(error, message, originalMessage) {\n    error.message = message;\n    error.originalMessage = originalMessage !== null && originalMessage !== void 0 ? originalMessage : error.originalMessage;\n    return error;\n}\n/**\n * @internal\n */\nexport function isTargetClosedError(err) {\n    return (err.message.includes('Target closed') ||\n        err.message.includes('Session closed'));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}