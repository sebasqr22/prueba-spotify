{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  constants: BufferConstants\n} = require('buffer');\nconst pump = require('pump');\nconst bufferStream = require('./buffer-stream');\nclass MaxBufferError extends Error {\n  constructor() {\n    super('maxBuffer exceeded');\n    this.name = 'MaxBufferError';\n  }\n}\nfunction getStream(_x, _x2) {\n  return _getStream.apply(this, arguments);\n}\nfunction _getStream() {\n  _getStream = _asyncToGenerator(function* (inputStream, options) {\n    if (!inputStream) {\n      return Promise.reject(new Error('Expected a stream'));\n    }\n    options = {\n      maxBuffer: Infinity,\n      ...options\n    };\n    const {\n      maxBuffer\n    } = options;\n    let stream;\n    yield new Promise((resolve, reject) => {\n      const rejectPromise = error => {\n        // Don't retrieve an oversized buffer.\n        if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n          error.bufferedData = stream.getBufferedValue();\n        }\n        reject(error);\n      };\n      stream = pump(inputStream, bufferStream(options), error => {\n        if (error) {\n          rejectPromise(error);\n          return;\n        }\n        resolve();\n      });\n      stream.on('data', () => {\n        if (stream.getBufferedLength() > maxBuffer) {\n          rejectPromise(new MaxBufferError());\n        }\n      });\n    });\n    return stream.getBufferedValue();\n  });\n  return _getStream.apply(this, arguments);\n}\nmodule.exports = getStream;\n// TODO: Remove this for the next major release\nmodule.exports.default = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {\n  ...options,\n  encoding: 'buffer'\n});\nmodule.exports.array = (stream, options) => getStream(stream, {\n  ...options,\n  array: true\n});\nmodule.exports.MaxBufferError = MaxBufferError;","map":{"version":3,"names":["constants","BufferConstants","require","pump","bufferStream","MaxBufferError","Error","constructor","name","getStream","inputStream","options","Promise","reject","maxBuffer","Infinity","stream","resolve","rejectPromise","error","getBufferedLength","MAX_LENGTH","bufferedData","getBufferedValue","on","module","exports","default","buffer","encoding","array"],"sources":["/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/extract-zip/node_modules/get-stream/index.js"],"sourcesContent":["'use strict';\nconst {constants: BufferConstants} = require('buffer');\nconst pump = require('pump');\nconst bufferStream = require('./buffer-stream');\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nasync function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\treturn Promise.reject(new Error('Expected a stream'));\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Infinity,\n\t\t...options\n\t};\n\n\tconst {maxBuffer} = options;\n\n\tlet stream;\n\tawait new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\t// Don't retrieve an oversized buffer.\n\t\t\tif (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(error);\n\t\t};\n\n\t\tstream = pump(inputStream, bufferStream(options), error => {\n\t\t\tif (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve();\n\t\t});\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t});\n\n\treturn stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\n// TODO: Remove this for the next major release\nmodule.exports.default = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});\nmodule.exports.array = (stream, options) => getStream(stream, {...options, array: true});\nmodule.exports.MaxBufferError = MaxBufferError;\n"],"mappings":"AAAA,YAAY;;AAAC;AACb,MAAM;EAACA,SAAS,EAAEC;AAAe,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACtD,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAME,YAAY,GAAGF,OAAO,CAAC,iBAAiB,CAAC;AAE/C,MAAMG,cAAc,SAASC,KAAK,CAAC;EAClCC,WAAW,GAAG;IACb,KAAK,CAAC,oBAAoB,CAAC;IAC3B,IAAI,CAACC,IAAI,GAAG,gBAAgB;EAC7B;AACD;AAAC,SAEcC,SAAS;EAAA;AAAA;AAAA;EAAA,+BAAxB,WAAyBC,WAAW,EAAEC,OAAO,EAAE;IAC9C,IAAI,CAACD,WAAW,EAAE;MACjB,OAAOE,OAAO,CAACC,MAAM,CAAC,IAAIP,KAAK,CAAC,mBAAmB,CAAC,CAAC;IACtD;IAEAK,OAAO,GAAG;MACTG,SAAS,EAAEC,QAAQ;MACnB,GAAGJ;IACJ,CAAC;IAED,MAAM;MAACG;IAAS,CAAC,GAAGH,OAAO;IAE3B,IAAIK,MAAM;IACV,MAAM,IAAIJ,OAAO,CAAC,CAACK,OAAO,EAAEJ,MAAM,KAAK;MACtC,MAAMK,aAAa,GAAGC,KAAK,IAAI;QAC9B;QACA,IAAIA,KAAK,IAAIH,MAAM,CAACI,iBAAiB,EAAE,IAAInB,eAAe,CAACoB,UAAU,EAAE;UACtEF,KAAK,CAACG,YAAY,GAAGN,MAAM,CAACO,gBAAgB,EAAE;QAC/C;QAEAV,MAAM,CAACM,KAAK,CAAC;MACd,CAAC;MAEDH,MAAM,GAAGb,IAAI,CAACO,WAAW,EAAEN,YAAY,CAACO,OAAO,CAAC,EAAEQ,KAAK,IAAI;QAC1D,IAAIA,KAAK,EAAE;UACVD,aAAa,CAACC,KAAK,CAAC;UACpB;QACD;QAEAF,OAAO,EAAE;MACV,CAAC,CAAC;MAEFD,MAAM,CAACQ,EAAE,CAAC,MAAM,EAAE,MAAM;QACvB,IAAIR,MAAM,CAACI,iBAAiB,EAAE,GAAGN,SAAS,EAAE;UAC3CI,aAAa,CAAC,IAAIb,cAAc,EAAE,CAAC;QACpC;MACD,CAAC,CAAC;IACH,CAAC,CAAC;IAEF,OAAOW,MAAM,CAACO,gBAAgB,EAAE;EACjC,CAAC;EAAA;AAAA;AAEDE,MAAM,CAACC,OAAO,GAAGjB,SAAS;AAC1B;AACAgB,MAAM,CAACC,OAAO,CAACC,OAAO,GAAGlB,SAAS;AAClCgB,MAAM,CAACC,OAAO,CAACE,MAAM,GAAG,CAACZ,MAAM,EAAEL,OAAO,KAAKF,SAAS,CAACO,MAAM,EAAE;EAAC,GAAGL,OAAO;EAAEkB,QAAQ,EAAE;AAAQ,CAAC,CAAC;AAChGJ,MAAM,CAACC,OAAO,CAACI,KAAK,GAAG,CAACd,MAAM,EAAEL,OAAO,KAAKF,SAAS,CAACO,MAAM,EAAE;EAAC,GAAGL,OAAO;EAAEmB,KAAK,EAAE;AAAI,CAAC,CAAC;AACxFL,MAAM,CAACC,OAAO,CAACrB,cAAc,GAAGA,cAAc"},"metadata":{},"sourceType":"script","externalDependencies":[]}