{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createWriteStream } from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { URL } from 'url';\nimport createHttpsProxyAgent from 'https-proxy-agent';\nimport { getProxyForUrl } from 'proxy-from-env';\nexport function headHttpRequest(url) {\n  return new Promise(resolve => {\n    const request = httpRequest(url, 'HEAD', response => {\n      resolve(response.statusCode === 200);\n    }, false);\n    request.on('error', () => {\n      resolve(false);\n    });\n  });\n}\nexport function httpRequest(url, method, response, keepAlive = true) {\n  const options = {\n    protocol: url.protocol,\n    hostname: url.hostname,\n    port: url.port,\n    path: url.pathname + url.search,\n    method,\n    headers: keepAlive ? {\n      Connection: 'keep-alive'\n    } : undefined\n  };\n  const proxyURL = getProxyForUrl(url.toString());\n  if (proxyURL) {\n    const proxy = new URL(proxyURL);\n    if (proxy.protocol === 'http:') {\n      options.path = url.href;\n      options.hostname = proxy.hostname;\n      options.protocol = proxy.protocol;\n      options.port = proxy.port;\n    } else {\n      options.agent = createHttpsProxyAgent({\n        host: proxy.host,\n        path: proxy.pathname,\n        port: proxy.port,\n        secureProxy: proxy.protocol === 'https:',\n        headers: options.headers\n      });\n    }\n  }\n  const requestCallback = res => {\n    if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      httpRequest(new URL(res.headers.location), method, response);\n    } else {\n      response(res);\n    }\n  };\n  const request = options.protocol === 'https:' ? https.request(options, requestCallback) : http.request(options, requestCallback);\n  request.end();\n  return request;\n}\n/**\n * @internal\n */\nexport function downloadFile(url, destinationPath, progressCallback) {\n  return new Promise((resolve, reject) => {\n    let downloadedBytes = 0;\n    let totalBytes = 0;\n    function onData(chunk) {\n      downloadedBytes += chunk.length;\n      progressCallback(downloadedBytes, totalBytes);\n    }\n    const request = httpRequest(url, 'GET', response => {\n      if (response.statusCode !== 200) {\n        const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);\n        // consume response data to free up memory\n        response.resume();\n        reject(error);\n        return;\n      }\n      const file = createWriteStream(destinationPath);\n      file.on('finish', () => {\n        return resolve();\n      });\n      file.on('error', error => {\n        return reject(error);\n      });\n      response.pipe(file);\n      totalBytes = parseInt(response.headers['content-length'], 10);\n      if (progressCallback) {\n        response.on('data', onData);\n      }\n    });\n    request.on('error', error => {\n      return reject(error);\n    });\n  });\n}","map":{"version":3,"names":["createWriteStream","http","https","URL","createHttpsProxyAgent","getProxyForUrl","headHttpRequest","url","Promise","resolve","request","httpRequest","response","statusCode","on","method","keepAlive","options","protocol","hostname","port","path","pathname","search","headers","Connection","undefined","proxyURL","toString","proxy","href","agent","host","secureProxy","requestCallback","res","location","end","downloadFile","destinationPath","progressCallback","reject","downloadedBytes","totalBytes","onData","chunk","length","error","Error","resume","file","pipe","parseInt"],"sources":["/Users/sebastianqr.2208/Desktop/Status Tech/prueba-spotify/node_modules/@puppeteer/browsers/lib/esm/httpUtil.js"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createWriteStream } from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { URL } from 'url';\nimport createHttpsProxyAgent from 'https-proxy-agent';\nimport { getProxyForUrl } from 'proxy-from-env';\nexport function headHttpRequest(url) {\n    return new Promise(resolve => {\n        const request = httpRequest(url, 'HEAD', response => {\n            resolve(response.statusCode === 200);\n        }, false);\n        request.on('error', () => {\n            resolve(false);\n        });\n    });\n}\nexport function httpRequest(url, method, response, keepAlive = true) {\n    const options = {\n        protocol: url.protocol,\n        hostname: url.hostname,\n        port: url.port,\n        path: url.pathname + url.search,\n        method,\n        headers: keepAlive ? { Connection: 'keep-alive' } : undefined,\n    };\n    const proxyURL = getProxyForUrl(url.toString());\n    if (proxyURL) {\n        const proxy = new URL(proxyURL);\n        if (proxy.protocol === 'http:') {\n            options.path = url.href;\n            options.hostname = proxy.hostname;\n            options.protocol = proxy.protocol;\n            options.port = proxy.port;\n        }\n        else {\n            options.agent = createHttpsProxyAgent({\n                host: proxy.host,\n                path: proxy.pathname,\n                port: proxy.port,\n                secureProxy: proxy.protocol === 'https:',\n                headers: options.headers,\n            });\n        }\n    }\n    const requestCallback = (res) => {\n        if (res.statusCode &&\n            res.statusCode >= 300 &&\n            res.statusCode < 400 &&\n            res.headers.location) {\n            httpRequest(new URL(res.headers.location), method, response);\n        }\n        else {\n            response(res);\n        }\n    };\n    const request = options.protocol === 'https:'\n        ? https.request(options, requestCallback)\n        : http.request(options, requestCallback);\n    request.end();\n    return request;\n}\n/**\n * @internal\n */\nexport function downloadFile(url, destinationPath, progressCallback) {\n    return new Promise((resolve, reject) => {\n        let downloadedBytes = 0;\n        let totalBytes = 0;\n        function onData(chunk) {\n            downloadedBytes += chunk.length;\n            progressCallback(downloadedBytes, totalBytes);\n        }\n        const request = httpRequest(url, 'GET', response => {\n            if (response.statusCode !== 200) {\n                const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);\n                // consume response data to free up memory\n                response.resume();\n                reject(error);\n                return;\n            }\n            const file = createWriteStream(destinationPath);\n            file.on('finish', () => {\n                return resolve();\n            });\n            file.on('error', error => {\n                return reject(error);\n            });\n            response.pipe(file);\n            totalBytes = parseInt(response.headers['content-length'], 10);\n            if (progressCallback) {\n                response.on('data', onData);\n            }\n        });\n        request.on('error', error => {\n            return reject(error);\n        });\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}